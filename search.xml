<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iVIew对话框组件封装]]></title>
    <url>%2F2019%2F01%2F30%2FiVIew%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[弹出框使用率较高，将其封装为组件 @/components/tip-modal/index.vue: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;template&gt; &lt;Modal v-scoped :width=&quot;width&quot; v-model=&quot;showTipFlag&quot; :title=&quot;title&quot; :mask-closable=&quot;false&quot; @on-cancel=&quot;cancel&quot; class-name=&quot;vertical-center-modal&quot;&gt; &lt;div class=&quot;cnt&quot;&gt; &lt;slot name=&quot;main-content&quot;&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div v-if=&quot;showFooter&quot; slot=&quot;footer&quot;&gt; &lt;Button type=&quot;primary&quot; @click.native=&quot;ok&quot;&gt;确定&lt;/Button&gt; &lt;Button @click.native=&quot;cancel&quot;&gt;取消&lt;/Button&gt; &lt;/div&gt; &lt;div v-else slot=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/Modal&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;TipModal&apos;, props: &#123; title: &#123; type: String, default: &apos;提示信息&apos; &#125;, width: &#123; type: Number, default: 535 &#125;, showTipFlag: &#123; required: true, type: Boolean &#125;, showFooter: &#123; type: Boolean, default: true &#125; &#125;, methods: &#123; _updateVisible(flag) &#123; this.showTipFlag = flag; this.$emit(&apos;update:showTipFlag&apos;, this.showTipFlag); //更新对话框的显示状态 &#125;, ok() &#123; this.$emit(&apos;click-ok&apos;); this._updateVisible(false); &#125;, cancel() &#123; this.$emit(&apos;click-cancel&apos;); this._updateVisible(false); &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.cnt &#123; max-height: 500px; overflow: auto;&#125;.vertical-center-modal &#123; display: flex; align-items: center; justify-content: center; .ivu-modal &#123; top: 0; &#125;&#125;.ivu-modal-header-inner &#123; font-size: 20px; font-weight: normal;&#125;.tip-text &#123; font-weight: bolder; color: #2d8cf0; font-size: 18px; line-height: 1.5;&#125;.tip-text-assist &#123; color: #a6a4a6; font-size: 15px;&#125;&lt;/style&gt; 使用： 123&lt;TipModal :showTipFlag.sync="addSuccessFlag" :title="'提示'" @click-ok="loadData()" :showFooter="false"&gt; 新增成功&lt;/TipModal&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[npm包：删除文件夹rimraf]]></title>
    <url>%2F2019%2F01%2F30%2Fnpm%E5%8C%85%EF%BC%9A%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9rimraf%2F</url>
    <content type="text"><![CDATA[当需要删除node_modules文件夹时，通常都会很慢，可以安装npm包：rimraf来快速删除。 全局安装 1npm install rimraf -g 进入目录，删除 1rimraf node_modules 同样可以使用于代码中， 1npm install rimraf --save-dev 1234const rimraf = require('rimraf');rimraf('./test.txt', function (err) &#123; // 删除当前目录下的 test.txt console.log(err);&#125;);]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[表单禁用默认提交]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%A1%A8%E5%8D%95%E7%A6%81%E7%94%A8%E9%BB%98%E8%AE%A4%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[W3C 标准中有如下规定： 当一个 form 元素中只有一个输入框时，在该输入框中按下回车应提交该表单。 通常我们希望阻止这一默认行为。 使用原生form时： 123&lt;form onsubmit="return false;"&gt; ......&lt;/form&gt; 使用iView的Form时： 123&lt;form @submit.native.prevent&gt; ......&lt;/form&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pointer-events用法]]></title>
    <url>%2F2019%2F01%2F30%2Fpointer-events%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[pointer-events用于屏蔽鼠标事件 使用pointer-events属性可以屏蔽鼠标事件。 或者让鼠标点击穿透上层元素。当绝对定位时，由于上层遮挡无法点击下层，可以在上层使用pointer-events: none]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue中使用高德地图]]></title>
    <url>%2F2019%2F01%2F30%2FVue%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[在Vue中使用高德地图，包括标记、搜索、自动补全功能。（不使用vue-amap） 引入/idnex.html: 1&lt;script type="text/javascript" src="http://webapi.amap.com/maps?v=1.4.10&amp;key=3bcadc9fa8870c7db8912575f009bdfb&amp;plugin=AMap.Autocomplete,AMap.Geocoder,AMap.PlaceSearch"&gt;&lt;/script&gt; 注意版本为1.4，低版本在Vue中会报错 key为自己的密钥。plugin后带的是插件 地图组件封装模板： 12345678910&lt;template&gt; &lt;div class="map-engine"&gt; &lt;div class="search" v-show="mapFlag"&gt; &lt;p&gt;请输入关键字：&lt;/p&gt; &lt;input type="text" id="tipInput" style="width: 250px" v-model="searchInput"&gt; &lt;/div&gt; &lt;div id="container" class="container" v-show="mapFlag"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; data: 12345678910111213data() &#123; return &#123; mapFlag: false, // 是否显示地图 map: null, // 地图示例 marker: null, // 标记 searchInput: '', // 搜索 markers: [], // 搜索产生的多个标记 lng: '', lat: '', address: '', currentPositionId: '' //当前的位置Id &#125;;&#125;, props： 12345678910props: &#123; locationObj: &#123; type: Object, default: () =&gt; (&#123; address: '当前位置', lng: '', lat: '' &#125;) &#125;&#125;, 初始化时，生成地图实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859mounted() &#123; // 忽略eslint的报错 /* eslint-disable no-undef */ window.map = this.map = new AMap.Map('container', &#123; resizeEnable: true, dragEnable: true, keyboardEnable: false, doubleClickZoom: true, zoom: 15 &#125;); // 绑定点击事件 this.map.on('click', this.clickHandler); // 搜索框 let auto = new AMap.Autocomplete(&#123; input: 'tipInput' &#125;); let placeSearch = new AMap.PlaceSearch(&#123; map: '' &#125;); //监听地名的选择 AMap.event.addListener(auto, 'select', e =&gt; &#123; placeSearch.setCity(e.poi.adcode); // 设置城市的 编码 // 地图定位城市 if (e.poi &amp;&amp; e.poi.location) &#123; this.map.setZoom(18); this.map.setCenter(e.poi.location); &#125; // 查询位置 并添加maker placeSearch.search(e.poi.name, (status, result) =&gt; &#123; if (status === 'complete' &amp;&amp; result.info === 'OK') &#123; for (let h = 0; h &lt; result.poiList.pois.length; h++) &#123; //返回搜索列表循环绑定marker let position = result.poiList.pois[h]['location']; //经纬度 let address = result.poiList.pois[h]['address']; //地址 let marker = new AMap.Marker(&#123; map: this.map, position: position &#125;); this.markers.push(marker); marker.extData = &#123; getLng: position['lng'], getLat: position['lat'], address: address &#125;; marker.on('click', e =&gt; &#123; let addressObj = &#123; address: e.target.extData.address, lng: position['lng'], lat: position['lat'] &#125;; this.changeAddress(addressObj); &#125;); &#125; &#125; &#125;); &#125;);&#125;, methods: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 获取地图实例getMap: function(found) &#123; var vm = this; function checkForMap() &#123; if (vm.map) &#123; found(vm.map); &#125; else &#123; setTimeout(checkForMap, 50); &#125; &#125; checkForMap();&#125;,// 监听地图 点击 事件clickHandler(e) &#123; this.lng = e.lnglat.getLng(); this.lat = e.lnglat.getLat(); // 点击添加标记并显示地名 this.getMap(map =&gt; &#123; // 取消上一个标记 if (this.marker) &#123; map.remove(this.marker); &#125; this.marker = new AMap.Marker(&#123; position: new AMap.LngLat(e.lnglat.getLng(), e.lnglat.getLat()) &#125;); // 添加标记 map.add(this.marker); //获取地名 let lnglatXY = [e.lnglat.getLng(), e.lnglat.getLat()]; let geocoder = new AMap.Geocoder(&#123; radius: 1000, extensions: 'all' &#125;); geocoder.getAddress(lnglatXY, (status, result) =&gt; &#123; if (status === 'complete' &amp;&amp; result.info === 'OK') &#123; let address = result.regeocode.formattedAddress; let addressObj = &#123; address: address, lng: e.lnglat.getLng(), lat: e.lnglat.getLat() &#125;; this.changeAddress(addressObj); &#125; &#125;); &#125;);&#125;,// 展开、关闭地图toggleMap(positionId) &#123; //清除所有的覆盖物 if (this.map) &#123; this.map.clearMap(); this.searchInput = ''; &#125; if (positionId === this.currentPositionId) &#123; this.currentPositionId = ''; //关闭地图 this.mapFlag = !this.mapFlag;&#125; else &#123; this.currentPositionId = positionId; //当前的 positionId this.mapFlag = true;&#125;if (this.mapFlag) &#123; // 如果带坐标，则回显 if (this.lng &amp;&amp; this.lat) &#123; this.map.setZoomAndCenter(15, [this.lng, this.lat]); this.getMap(map =&gt; &#123; this.marker = new AMap.Marker(&#123; position: [this.lng, this.lat] &#125;); map.add(this.marker); &#125;); &#125;&#125;/* else &#123; // 清除标记 if (this.marker) &#123; this.map.remove(this.marker); &#125; if (this.markers.length) &#123; this.markers.forEach(item =&gt; &#123; this.map.remove(item); &#125;); &#125; // 清除搜索 this.searchInput = ''; &#125; */&#125;,// 数据变换并抛出changeAddress(addressObj) &#123; this.address = addressObj.address; Object.assign(addressObj, &#123; id: this.currentPositionId &#125;); this.$emit('click-position', addressObj);&#125; watch： 12345678locationObj: &#123; handler: function() &#123; this.lat = this.locationObj.lat; this.lng = this.locationObj.lng; this.address = this.locationObj.address; &#125;, deep: true&#125; destroyed； 1234destroyed() &#123; //销毁地图资源 this.map &amp;&amp; this.map.destroy();&#125; 样式： 1234567891011121314151617181920212223242526&lt;style scoped&gt;.map-engine &#123; position: relative;&#125;.container &#123; width: 100%; height: 600px;&#125;.search &#123; border: 1px solid #ccc; width: 270px; height: 70px; background-color: #fff; position: absolute; top: 30px; left: 0; z-index: 99; padding-top: 8px; padding-left: 8px;&#125;.look &#123; pointer-events: none; outline: none;&#125;&lt;/style&gt; 使用模板： 12345678910111213141516171819&lt;Row style="margin: 8px 0" v-for="item in positionList" :key="item.id"&gt; &lt;Col :span="12"&gt; &lt;Input type="text" :value="item.description" :readonly="true" /&gt; &lt;/Col&gt; &lt;Col :span="4"&gt; &lt;div class="map-op"&gt; &lt;a :class="&#123;btn:true,choose:item.id === currentPositionId&#125;" href="javascript:void(0)" @click="chooseMap(item.id)"&gt;选择地图&lt;/a&gt; | &lt;a class="btn" href="javascript:void(0)" @click="deleteHandler(item.id)"&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;/Col&gt;&lt;/Row&gt;&lt;MapEngine ref="mapEngine" :locationObj="currentGeoCord" @click-position="positionHandler"&gt;&lt;/MapEngine&gt; 12345import MapEngine from '@/components/map-engine';components: &#123; MapEngine&#125; data: 1234567positionList: [], // 表单外置获取的地理位置列表currentPositionId: '', //当前操作的记录currentGeoCord: &#123; address: '当地位置', lng: '', lat: ''&#125;, created： 初始时，获取已经有的位置列表 123created() &#123; this.positionList=&#125; methods: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 打开、关闭地图chooseMap(positionId) &#123; this.currentPositionId = positionId; let positionRecord = this._getPositionById(positionId); if (!positionRecord.latitude &amp;&amp; !positionRecord.longitude) &#123; //恢复默认值 this.currentGeoCord = &#123; address: '当地位置', lng: '', lat: '' &#125;; &#125; else &#123; this.currentGeoCord = &#123; address: positionRecord.description, lat: positionRecord.latitude, lng: positionRecord.longitude &#125;; &#125; // 让mapEngine里面的 watch先执行 this.$nextTick(() =&gt; &#123; this.$refs.mapEngine.toggleMap(positionId); &#125;);&#125;, _getPositionById(positionId) &#123; return this.positionList.find(item =&gt; &#123; return item.id === positionId; &#125;);&#125;, // 点击地图positionHandler(geoCord) &#123; let record = this.positionList.find(item =&gt; &#123; return item.id === geoCord.id; &#125;); Object.assign(record, &#123; latitude: geoCord.lat, longitude: geoCord.lng, description: geoCord.address &#125;);&#125;,// 删除位置deleteHandler(positionId) &#123; this.positionList = this.positionList.filter(item =&gt; &#123; return item.id != positionId; &#125;); //关闭地图 if (this.currentPositionId === positionId) &#123; this.$refs.mapEngine.toggleMap(positionId); this.currentPositionId = ''; // 清空选中的样式 &#125;&#125;,// 添加位置addHandler() &#123; this.positionList.push(this._getPositionRecord());&#125;,_getPositionRecord() &#123; let id = this.uniqueId++; let positionRecord = &#123; id, latitude: '', longitude: '', description: '' &#125;; return positionRecord;&#125;, 效果：]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[路由拦截器]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[每次路由变化时，判断是否登录、是否有权限 注入拦截器@/router/index.js: 1234567import &#123; routerBeforeEachFunc, routerAfterEachFunc &#125; from '@/config/interceptor/router';// 注入拦截器routerInstance.beforeEach(routerBeforeEachFunc);routerInstance.afterEach(routerAfterEachFunc);export default routerInstance; @/index.js: 1234567import router from '@/router';window.app = new Vue(&#123; el: '#app', router, render: h =&gt; h(App)&#125;); 拦截器设置设置loadingBar，判断是否登录、是否有权限 @/config/interceptor: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import router from '@/router';import store from '@/store';import &#123; getToken &#125; from '@/utils/auth'; // getToken from cookieimport &#123; treeToList &#125; from '../../utils';import iView from 'iview';//设置加载条的高度iView.LoadingBar.config(&#123; height: 3&#125;);function hasPermission(urlList, to) &#123; if (to.meta.noControl) return true; return urlList.includes(to.path || to.meta.fullPath);&#125;const whiteList = ['/login']; // no redirect whitelistexport function routerBeforeEachFunc(to, from, next) &#123; iView.LoadingBar.start(); if (to.meta.title) &#123; document.title = to.meta.title; &#125; window.currentRoute = to; //保存当前的路由,功能按钮权限访问 if (getToken()) &#123; // determine if there has token是否登录 使用本地缓存Cookie /* has token 已经登录了访问login 直接跳转到 dashboard*/ if (to.path === '/login') &#123; next(&#123; path: '/' &#125;); iView.LoadingBar.finish(); //hack 技巧 if current page is dashboard will not trigger afterEach hook, so manually handle it &#125; else &#123; // 每次刷新 都重新的获取权限 if (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完user_info信息 store .dispatch('GetUserInfo') .then(res =&gt; &#123; // 获取全局的菜单 const routeTreeData = res; let routeList = treeToList(routeTreeData); // 对比代码配置的路由对象 与服务器点返回的路由 生成路由表 store.dispatch('GenerateRoutes', routeList).then(() =&gt; &#123; // 根据roles权限生成可访问的路由表 router.addRoutes(store.getters.addRouters); // 动态添加可访问路由表 // 以由当前用角色 改变[左侧渲染菜单] store.dispatch('ChangeRoles'); // 下次再进入路由时候 直接走else进入到动态添加的路由中 next(&#123; ...to, replace: true &#125;); // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record &#125;); &#125;) .catch(err =&gt; &#123; store.dispatch('FedLogOut').then(() =&gt; &#123; iView.Message.error('获取角色信息失败,请重新登录'); next(&#123; path: '/' &#125;); &#125;); &#125;); &#125; else &#123; // 没有动态的改变权限则直接进入 // next(); // 改变角色会改变vuex保存的路由，所以这里要判断 if (hasPermission(store.getters.addUrlList, to)) &#123; next(); &#125; else &#123; // 进入未授权的页面 next(&#123; path: '/401', replace: true, query: &#123; noGoBack: true &#125; &#125;); &#125; &#125; &#125; &#125; else &#123; /* has no token*/ // 白名单里面初始化 if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入 next(); &#125; else &#123; next(`/login?redirect=$&#123;to.path&#125;`); // 否则全部重定向到登录页 iView.LoadingBar.finish(); // if current page is login will not trigger afterEach hook, so manually handle it &#125; &#125;&#125;export function routerAfterEachFunc(to, from) &#123; iView.LoadingBar.finish();&#125; 引用模块@/utils/auth.js: 12345import Cookies from 'js-cookie';const TokenKey = 'Admin-Token';export function getToken() &#123; return Cookies.get(TokenKey);&#125; @/utils/index.js: 12345678910111213141516171819export function treeToList(routeList) &#123; let res = []; function foo(nodeData) &#123; let &#123; resourceName, resourceUrl, children, actionVOS &#125; = nodeData; // 过滤掉 resourceUrl是null的选项 if (resourceUrl) res.push(&#123; resourceName, resourceUrl, actionVOS &#125;); // children 挂载的是子节点 if (!isEmpty(children)) &#123; children.forEach(item =&gt; &#123; foo(item); &#125;); &#125; &#125; routeList.forEach(item =&gt; &#123; foo(item); &#125;); return res;&#125; @/store/user.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109const user = &#123; // actions中可以使用 async函数 actions: &#123; // 获取用户信息 角色及对应的路由表 在路由的钩子中调用 async GetUserInfo(&#123; commit, state, dispatch &#125;) &#123; await api['user/getRolePermission']().then(data =&gt; &#123; if (isEmpty(data)) &#123; throw new Error('getRolePermission: getRolePermission must be a non-null array !'); &#125; else &#123; // 注意这里的角色data 是数组 用户对应多个角色 commit('SET_ROLES', data); let roleId = sessionStorage.getItem('currentRoleId'); if (roleId) &#123; let roleObj = data.find(item =&gt; &#123; return item.id == roleId; &#125;); if (roleObj) &#123; commit('SET_CURRENT_ROLE', roleObj); &#125; else &#123; throw new Error('用户的同名的角色id值前后不一致'); &#125; &#125; else &#123; // 默认使用第一个权限 作为默认权限 commit('SET_CURRENT_ROLE', data[0]); &#125; &#125; &#125;); // 获取全局菜单 let allRouteList = await api['user/globalMenuResource']().then(data =&gt; &#123; if (isEmpty(data)) &#123; throw new Error('globalMenuResource: globalMenuResource must be a non-null array !'); &#125; else &#123; return data; &#125; &#125;); commit('SET_GLOBAL_MENU', allRouteList); //设置全局菜单 return allRouteList; &#125;, // 前端 登出 FedLogOut(&#123; commit &#125;) &#123; return new Promise(resolve =&gt; &#123; commit('SET_TOKEN', ''); removeToken(); sessionStorage.removeItem('currentRoleId'); resolve(); router.push(&#123; name: 'login' &#125;); &#125;); &#125;, //动态的改变 用户权限 修改左侧的菜单 ChangeRoles(&#123; state, commit, dispatch &#125;, role) &#123; let routeList; if (role) &#123; commit('SET_CURRENT_ROLE', role); routeList = role.resourceVOS; //该角色能够访问的菜单 &#125; else &#123; routeList = state.currentRole.resourceVOS; &#125; let urlList = treeToList(routeList); dispatch('GenerateRoutes', urlList); &#125;, GenerateRoutes(&#123; state, commit &#125;, routeList) &#123; return new Promise(resolve =&gt; &#123; let urlList = []; routeList.forEach(item =&gt; &#123; urlList.push(item.resourceUrl); &#125;); let accessedRouters = filterAsyncRouter(asyncRouterMap, urlList); // 动态的控制左侧菜单的 显示隐藏 commit('SET_ROUTERS', accessedRouters); commit('SET_ADD_URLLIST', urlList); resolve(); &#125;); &#125; &#125;, mutations: &#123; SET_ROUTERS: (state, routers) =&gt; &#123; state.addRouters = routers; state.routers = constantRouterMap.concat(routers); &#125;, SET_ADD_URLLIST: (state, urlList) =&gt; &#123; state.addUrlList = urlList; &#125;, SET_CODE: (state, code) =&gt; &#123; state.code = code; &#125;, SET_TOKEN: (state, token) =&gt; &#123; state.token = token; &#125;, SET_INTRODUCTION: (state, introduction) =&gt; &#123; state.introduction = introduction; &#125;, SET_STATUS: (state, status) =&gt; &#123; state.status = status; &#125;, SET_USER_NAME: (state, name) =&gt; &#123; state.userName = name; &#125;, SET_AVATAR: (state, avatar) =&gt; &#123; state.avatar = avatar; &#125;, SET_ROLES: (state, roles) =&gt; &#123; state.roles = roles; &#125;, SET_CURRENT_ROLE: (state, role) =&gt; &#123; state.currentRole = role; // 设置当前系统使用角色 sessionStorage.setItem('currentRoleId', role.id); // 角色的id 保存在当前会话 &#125; &#125;,&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iView无限滚动Scroll组件]]></title>
    <url>%2F2019%2F01%2F29%2FiView%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8Scroll%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一般来说，数据量太大时使用分页。但由于某些第三方因素无法使用分页时，可以使用无限滚动来展示数据，避免数据量太大时的渲染延迟。 12345&lt;Scroll :on-reach-bottom="handleReachBottom"&gt; &lt;CheckboxGroup v-model="chooseSearchProject" style="display:flex;flex-direction:column;"&gt; &lt;Checkbox :label="item.id" v-for="(item,index) in list1" :key="index"&gt;&#123;&#123;item.pName&#125;&#125;&lt;/Checkbox&gt; &lt;/CheckboxGroup&gt;&lt;/Scroll&gt; data: 123chooseSearchProject: [], // 搜索项目中选中的项idsearchProjectList: [], // 搜索项目中的全部待选项list1: [] // 已渲染的项目 初始时，若数据量大于100条，则只展示100条 created: 123456789101112131415this.$api['schoolManage/findRelatedItems'](&#123; marketArea: this.searchData.marketRegion, pName: this.searchData.projectName&#125;).then(data =&gt; &#123; this.searchProjectList = data; // this.allDataList = data; if (data.length &gt; 100) &#123; for (let i = 0; i &lt; 100; i++) &#123; this.list1.push(data[i]); &#125; &#125; else &#123; this.list1 = data; &#125;&#125;);&#125;, 下拉触底时，需返回 Promise methods: 123456789101112handleReachBottom() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; const lastIndex = this.list1.length; const allLength = this.searchProjectList.length; for (let i = lastIndex; i &lt; lastIndex + 100 &amp;&amp; i &lt; allLength - 1; i++) &#123; this.list1.push(this.searchProjectList[i]); &#125; resolve(); &#125;, 1000); &#125;);&#125;,]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[序号动态改变]]></title>
    <url>%2F2019%2F01%2F29%2F%E5%BA%8F%E5%8F%B7%E5%8A%A8%E6%80%81%E6%94%B9%E5%8F%98%2F</url>
    <content type="text"><![CDATA[在问卷调查中，常常根据前一题的选择情况来动态渲染后续题目。序号也要相应变化。 123&lt;p&gt; &#123;&#123;getIndex(0)&#125;&#125;.&#123;&#123;allNaireList[0].title&#125;&#125;&lt;/p&gt; data： 1nowIndexArr: [] // 存储序号 created: 1234// 开始时默认全显示for (let i = 1; i &lt;= 22; i++) &#123; this.nowIndexArr.push(true);&#125; methods: 12345678910// 取序号，即取当前项在数组汇中，前面的true的个数getIndex(index) &#123; let count = 0; for (let i = 0; i &lt;= index; i++) &#123; if (this.nowIndexArr[i]) &#123; count++; &#125; &#125; return count;&#125;, watch: 12345678// 监听某一题不显示时，将该题在数组中的状态由true改为falseshowQue2(val) &#123; if (!val) &#123; this.nowIndexArr.splice(1, 1, false); &#125; else &#123; this.nowIndexArr.splice(1, 1, true); &#125;&#125;,]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[axios封装及api调用方法]]></title>
    <url>%2F2019%2F01%2F25%2Faxios%E5%B0%81%E8%A3%85%E5%8F%8Aapi%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[记录项目中axios的封装及api调用方法 入口@/index.js: 12345678910import Vue from 'vue';// 导入插件import plugin from '@/plugins';Vue.use(plugin);window.app = new Vue(&#123; el: '#app', // store, // router, render: h =&gt; h(App)&#125;); axios封装@/plugins/axios.js: 123456789101112131415import axios from 'axios';import &#123; AXIOS_DEFAULT_CONFIG &#125; from '@/config'; // axios 默认配置import &#123; requestSuccessFunc, requestFailFunc, responseSuccessFunc, responseFailFunc &#125; from '@/config/interceptor/axios'; // 各个拦截器let axiosInstance = &#123;&#125;;axiosInstance = axios.create(AXIOS_DEFAULT_CONFIG); // axios实例// 注入请求拦截axiosInstance.interceptors.request.use(requestSuccessFunc, requestFailFunc);// 注入返回拦截axiosInstance.interceptors.response.use(responseSuccessFunc, responseFailFunc);export default axiosInstance; 拦截器@/config/interceptor/axios.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173import axios from 'axios';import &#123; getToken &#125; from '@/utils/auth';import store from '@/store';import &#123; CONSOLE_REQUEST_ENABLE, CONSOLE_RESPONSE_ENABLE &#125; from '../index'; // 是否开启请求、响应参数打印import iView from 'iview';const CancelToken = axios.CancelToken;const source = CancelToken.source();let loadCount = 0, // 做loadingView的唯一标识 loadingNameArray = [];/** * 请求成功拦截器 * @param req 请求参数 * @returns &#123;*&#125; */export function requestSuccessFunc(req) &#123; //展示模态对话框 loadCount++; let loadingName = `load$&#123;loadCount&#125;`; // show方法需要个 全局唯一的名字 window.loadingView.show(loadingName); loadingNameArray.push(loadingName); req.cancelToken = source.token; // 所有请求使用 同一个token，出现网络错误时一起取消 CONSOLE_REQUEST_ENABLE &amp;&amp; console.info('requestInterceptorFunc', `url:$&#123;req.url&#125;`, req); // 自定义请求拦截逻辑，处理权限，请求发送监控等 if (store.getters.token) &#123; req.headers['token'] = getToken(); // 让每个请求携带token--['token']为自定义key 请根据实际情况自行修改 &#125; return req;&#125;/** * 请求失败拦截器 * @param reqError 失败信息 * @returns &#123;Promise.&lt;*&gt;&#125; */export function requestFailFunc(reqError) &#123; // 关闭模态对话框 loadCount--; if (!loadCount) &#123; loadingNameArray.forEach(item =&gt; window.loadingView.hide(item)); &#125; // 自定义请求失败逻辑，处理断网，请求发送监控等 return Promise.reject(reqError);&#125;/** * 响应成功拦截器 * @param res 返回数据 * @returns &#123;*&#125; */export function responseSuccessFunc(response) &#123; // 关闭模态对话框 loadCount--; if (!loadCount) &#123; loadingNameArray.forEach(item =&gt; window.loadingView.hide(item)); &#125; // 自定义响应成功逻辑，全局拦截接口，根据不同业务做不同处理，响应成功监控等 CONSOLE_RESPONSE_ENABLE &amp;&amp; console.info('responseInterceptorFunc', response); const httpStatusCode = &#123; 300: '资源已被转移至其他位置', 301: '请求的资源已被永久移动到新URI', 302: '请求的资源已被临时移动到新URI', 305: '请求的资源必须通过代理访问', 400: '错误资源访问请求', 401: '资源访问未授权', 403: '资源禁止访问', 404: '未找到要访问的资源', 405: '请更换请求方法', 406: '无法访问', 408: '请求超时', 413: '请求实体过大', 414: '请求URI过长', 500: '内部服务器错误', 501: '未实现', 503: '服务无法获得', 504: '接口访问超时' &#125;; if (response.status &gt;= 300 &amp;&amp; response.status &lt; 600) &#123; let errorMessage = '未知的访问错误，状态吗：' + String(res.status); if (httpStatusCode[String(res.status)]) &#123; errorMessage = httpStatusCode[String(res.status)]; iView.Message.error(errorMessage); //展示错误信息 return Promise.reject('error：' + errorMessage); &#125; &#125; // 自定义状态码 let statusCode = &#123; 301: '登录失败', 303: '退出失败', 304: '用户或密码错误', 400: '未查询到角色数据', 401: '资源访问未授权', 403: '验证码错误', 405: '验证码已过期' &#125;; const res = response.data; let code = res.code; if (Object.keys(statusCode).includes(String(code))) &#123; // 异常处理 console.log('warning', res.message); // iView.Message.error(res.message); //展示错误信息 iView.Message.error(&#123; content: res.message, duration: 10, closable: true &#125;); //展示错误信息 switch (code) &#123; case 301: &#123; location.href = '/login'; // 回退到登录界面 &#125; break; case 303: break; case 304: break; case 401: &#123; location.href = '/401'; // 跳转到未授权界面 &#125; break; &#125; return Promise.reject('error：' + (response &amp;&amp; response.data &amp;&amp; response.data.message)); &#125; if (['blob', 'arraybuffer'].includes(response.request.responseType)) &#123; let fileNameIndex = response.headers['content-disposition'].indexOf('='); let fileName = ''; if (fileNameIndex) &#123; let tmpName = response.headers['content-disposition'].slice(fileNameIndex + 1); fileName = window.decodeURIComponent(tmpName); &#125; return &#123; data: res, fileName &#125;; &#125; else &#123; return res.data; &#125;&#125;/** * 响应失败拦截器 * @param resError 失败信息 * @returns &#123;Promise.&lt;*&gt;&#125; * 请求的404 接口会返回这个handler中 * 请求超时 触发失败的回调 * 重复的接口取消 */export function responseFailFunc(resError) &#123; // 关闭模态对话框 loadCount--; if (!loadCount) &#123; loadingNameArray.forEach(item =&gt; window.loadingView.hide(item)); &#125; resError.message = resError.toString(); if (resError.toString().indexOf('Network') &gt; -1) &#123; resError.message = '网络连接异常'; //source.cancel(resError.message); Promise.reject('网络连接异常 '); &#125; console.warn(resError.message); // iView.Message.error(resError.message); //展示错误信息 iView.Message.error(&#123; content: resError.message, duration: 5, closable: true &#125;); // 响应失败，可根据resError信息做监控处理 return Promise.reject(resError);&#125; @/utils/auth/index.js: 123456import Cookies from 'js-cookie';const TokenKey = 'Admin-Token';export function getToken() &#123; return Cookies.get(TokenKey);&#125; @/config/index.js: 1234567891011121314151617// axios 默认配置export const AXIOS_DEFAULT_CONFIG = &#123; timeout: 20000, maxContentLength: 20000, headers: &#123; // 'Content-Type': 'application/x-www-form-urlencoded' 'Content-Type': 'application/json' // 跨域的时候会产生 options预检 &#125;, // baseURL: 'http://localhost:8080/xiaozhi-back-api' //可以换种写法 //baseURL: process.env.NODE_ENV !== 'production' ? '/xiaozhi-back-api' : 'http://172.16.130.164:8080/xiaozhi-back-api' baseURL: '/xiaozhi-back-api' // baseURL: '/'&#125;;// 开启请求参数打印export const CONSOLE_REQUEST_ENABLE = true;// 开启响应参数打印export const CONSOLE_RESPONSE_ENABLE = true; loadingView请求中状态 @/plugins/loadingView.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * loading状态效果 * 显示window.loadingView.show("loading名") * 隐藏window.loadingView.hide("loading名") * 注意：勿同时执行相同名称的loadingView */window._loadingViewArr = [];let animateTimer = 0;function createdView() &#123; let loadingView = document.createElement('div'); loadingView.className = 'loadingView animated fadeOut'; let frame = window.document.createElement('div'); frame.className = 'loadingViewFrame animated'; frame.innerHTML = `&lt;div class="loadingBox1 loadingBox"&gt;&lt;/div&gt; &lt;div class="loadingBox2 loadingBox"&gt;&lt;/div&gt; &lt;div class="loadingBox4 loadingBox"&gt;&lt;/div&gt; &lt;div class="loadingBox3 loadingBox"&gt;&lt;/div&gt;`; loadingView.appendChild(frame); window.document.body.appendChild(loadingView); return loadingView;&#125;function addClass(className) &#123; let classNameArr = this.className.replace(/[ ]+/g, ',').split(','); let index = classNameArr.indexOf(className); if (index &lt; 0) &#123; classNameArr.push(className); &#125; this.className = classNameArr.join(' ');&#125;function removeClass(className) &#123; let classNameArr = this.className.replace(/[ ]+/g, ',').split(','); let index = classNameArr.indexOf(className); if (index &gt;= 0) &#123; classNameArr.splice(index, 1); &#125; this.className = classNameArr.join(' ');&#125;function css(key, value) &#123; if (typeof key === 'string') &#123; if (value !== undefined) &#123; this.style[key] = value; return; &#125; else &#123; let style = this.style[key]; if (!style) &#123; style = window.getComputedStyle ? window.getComputedStyle(this, null)[key] : this.currentStyle[key]; &#125; return style; &#125; &#125; else if (typeof key === 'object') &#123; for (let name in key) &#123; this.style[name] = key[name]; &#125; &#125;&#125;let node = createdView();let showHide = function(_name, _isShow) &#123; if (!_name) return null; let loadingId = _name; let index = window._loadingViewArr.indexOf(loadingId); if (index &gt;= 0) &#123; if (_isShow) return true; window._loadingViewArr.splice(index, 1); &#125; else &#123; if (_isShow) &#123; window._loadingViewArr.push(loadingId); &#125; &#125; if (window._loadingViewArr.length) &#123; window.clearTimeout(animateTimer); css.bind(node)('display', 'block'); removeClass.bind(node)('fadeOut'); addClass.bind(node)('fadeIn'); &#125; else &#123; removeClass.bind(node)('fadeIn'); addClass.bind(node)('fadeOut'); window.clearTimeout(animateTimer); animateTimer = window.setTimeout(() =&gt; &#123; css.bind(node)('display', 'none'); &#125;, 1000); &#125; return window._loadingViewArr.length &gt; 0;&#125;;let loadingView = (window.loadingView = &#123; show(_name) &#123; return showHide(_name, true); &#125;, hide(_name) &#123; return showHide(_name, false); &#125;&#125;);export default loadingView; 样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071.loadingView &#123; position: fixed; left: 0; top: 0; width: 100%; height: 100%; // margin-left: -50px; // margin-right: -50px; // margin-top: -50px; z-index: 1999; display: none; background-color: rgba(255, 255, 255, 0.1); // background-color: red; .loadingViewFrame &#123; position: absolute; left: 50%; top: 50%; margin: -20px 0 0 -20px; width: 40px; height: 40px; -webkit-transform: rotateZ(45deg); transform: rotateZ(45deg); .loadingBox &#123; float: left; width: 50%; height: 50%; position: relative; -webkit-transform: scale(1.1); -ms-transform: scale(1.1); transform: scale(1.1); &#125; .loadingBox:before &#123; content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: @baseThemeColor; -webkit-animation: foldCubeAngle 2.4s infinite linear both; animation: foldCubeAngle 2.4s infinite linear both; -webkit-transform-origin: 100% 100%; -ms-transform-origin: 100% 100%; transform-origin: 100% 100%; &#125; .loadingBox2 &#123; -webkit-transform: scale(1.1) rotateZ(90deg); transform: scale(1.1) rotateZ(90deg); &#125; .loadingBox3 &#123; -webkit-transform: scale(1.1) rotateZ(180deg); transform: scale(1.1) rotateZ(180deg); &#125; .loadingBox4 &#123; -webkit-transform: scale(1.1) rotateZ(270deg); transform: scale(1.1) rotateZ(270deg); &#125; .loadingBox2:before &#123; -webkit-animation-delay: 0.3s; animation-delay: 0.3s; &#125; .loadingBox3:before &#123; -webkit-animation-delay: 0.6s; animation-delay: 0.6s; &#125; .loadingBox4:before &#123; -webkit-animation-delay: 0.9s; animation-delay: 0.9s; &#125; &#125;&#125; @/plugins/index.js: 1234567import loadingView from './loadingView';export default &#123; install: (Vue, options) =&gt; &#123; // 挂载实例 Vue.prototype.$loadingView = loadingView; &#125;&#125;; api请求方法封装@/plugins/api.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** @format */import axios from './axios';import _assign from 'lodash/assign';import _merge from 'lodash/merge';import &#123; assert &#125; from '@/utils'; // 断言import &#123; API_DEFAULT_CONFIG, AXIOS_DEFAULT_CONFIG &#125; from '@/config'; // 配置import API_CONFIG from '@/api';/** * 生成api接口类 */class Api &#123; constructor(options) &#123; this.api = &#123;&#125;; this.apiBuilder(options); &#125; /** * 创建工程接口 * @param sep 分隔符 * @param config 接口配置对象 * @param mock 是否开启mock * @param debug 是否开启debug模式 * @param mockBaseURL mock接口地址 */ apiBuilder(&#123; sep = '/', config = &#123;&#125;, mock = false, debug = false, mockBaseURL = '' &#125;) &#123; Object.keys(config).map(namespace =&gt; &#123; this._apiSingleBuilder(&#123; namespace, mock, mockBaseURL, sep, debug, config: config[namespace] &#125;); &#125;); &#125; /** * 创建单个接口 * @param sep 分隔符 * @param config 接口配置对象 * @param mock 是否开启mock * @param debug 是否开启debug模式 * @param mockBaseURL mock接口地址 */ _apiSingleBuilder(&#123; namespace, sep = '/', config = &#123;&#125;, mock = false, debug = false, mockBaseURL = '' &#125;) &#123; config.forEach(api =&gt; &#123; const &#123; name, desc, params, method, path &#125; = api; let apiname = `$&#123;namespace&#125;$&#123;sep&#125;$&#123;name&#125;`; // 接口调用名称 this.$api['apiname'](&#123;参数&#125;,&#123;HTTP请求的配置&#125;) let url = path; // 接口地址 const baseURL = mock ? mockBaseURL : AXIOS_DEFAULT_CONFIG.baseURL; // 接口base地址 debug &amp;&amp; assert(name, `$&#123;url&#125; :接口name属性不能为空`); debug &amp;&amp; assert(url.indexOf('/') === 0, `$&#123;url&#125; :接口路径path，首字符应为/`); // value可以使用函数调用符号 Object.defineProperty(this.api, `$&#123;apiname&#125;`, &#123; value(outerParams, outerOptions) &#123; // let _data = _isEmpty(outerParams) ? params : _pick(_assign(&#123;&#125;, params, outerParams), Object.keys(params)); // 未填的字段 使用默认值 未填的使用默认值 //todo FormData 则需要手动的设置请求头 Content-type:multipart/form-data let _data = Array.isArray(outerParams) || outerParams instanceof FormData ? outerParams : _merge(&#123;&#125;, params, outerParams); return axios(_normoalize(_assign(&#123; url, desc, baseURL, method &#125;, outerOptions), _data)); &#125; &#125;); &#125;); &#125;&#125;/** * 根据请求类型处理axios参数 * @param options * @param data * @returns &#123;*&#125; * @private */function _normoalize(options, data) &#123; if (options.method === 'POST') &#123; // 如果是 application/x-www-form-urlencoded 需要引入qs模块做参数处理 // options.data = qs.stringifly(data) options.data = data; &#125; else if (options.method === 'GET') &#123; options.params = data; &#125; return options;&#125;/** * 导出接口 */export default new Api(&#123; config: API_CONFIG, ...API_DEFAULT_CONFIG&#125;)['api']; 工具函数@/utils/index.js: 1234// 断言的内容export function assert(condition, msg) &#123; if (!condition) throw new Error(`[Apior] $&#123;msg&#125;`);&#125; 配置@/config/index.js: 123456789101112131415161718192021// axios 默认配置export const AXIOS_DEFAULT_CONFIG = &#123; timeout: 20000, maxContentLength: 20000, headers: &#123; // 'Content-Type': 'application/x-www-form-urlencoded' 'Content-Type': 'application/json' // 跨域的时候会产生 options预检 &#125;, // baseURL: 'http://localhost:8080/xiaozhi-back-api' //可以换种写法 //baseURL: process.env.NODE_ENV !== 'production' ? '/xiaozhi-back-api' : 'http://172.16.130.164:8080/xiaozhi-back-api' baseURL: '/xiaozhi-back-api' // baseURL: '/'&#125;;// API 默认配置export const API_DEFAULT_CONFIG = &#123; mockBaseURL: 'http://yapi.demo.qunar.com/mock/12982/flytest/v1', // mock地址 mock: false, // 是否开启mock debug: false, // 是否开启debug模式 sep: '/' // 接口调用分隔符&#125;; api接口地址@/api/index.js: 1234567import common from './common'; // 登录import schoolCount from './school-count'; // 学校统计export default &#123; ...common, ...schoolCount&#125;; 各个模块@/api/school-count/index.js: 12345import schoolContact from './school-contact';export default &#123; schoolContact&#125;; @/api/school-count/school-contact.js: 12345678export default [ &#123; name: 'teacherPageList', method: 'POST', desc: '获取学校联系人列表 ', path: '/fansTeacher/teacherPageList' &#125;]; 使用方法123456this.$api['schoolManage/schoolPageList'](&#123; pageSize: this.page.size, page: this.page.index&#125;).then(data =&gt; &#123; this.tableData = data.dataList;&#125;); 当需设置额外的Content-Type时： 123456789101112131415this.$api[this.uploadUrl](formData, &#123; headers: &#123; 'Content-Type': 'multipart/form-data' &#125;, timeout: 60000&#125;) .then(() =&gt; &#123; this.$Message.success(&#123; content: `$&#123;this.title&#125;信息文件上传成功!`, duration: 5, closable: true &#125;);&#125;) .finally(() =&gt; &#123;&#125;); 注： 此封装方法只能去到成功时的data值，失败时会展示接口message信息。 此封装方法默认Content-Type为application/json。如果是如果是 application/x-www-form-urlencoded 需要引入qs模块做参数处理 当需要在js文件中使用时： 12345678import api from '@/plugins/api';api['schoolManage/schoolPageList'](&#123; pageSize: this.page.size, page: this.page.index&#125;).then(data =&gt; &#123; this.tableData = data.dataList;&#125;);]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-Router+Vuex实战：多角色页面权限控制+面包屑]]></title>
    <url>%2F2019%2F01%2F24%2Fvue-Router%2BVuex%E5%AE%9E%E6%88%98%EF%BC%9A%E9%A1%B5%E9%9D%A2%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2B%E9%9D%A2%E5%8C%85%E5%B1%91%2F</url>
    <content type="text"><![CDATA[介绍多角色的页面权限控制方法 面包屑的封装和使用 VuexVuex入口@/store/index.js: 123456789101112131415161718192021import Vue from 'vue';import Vuex from 'vuex';import app from './modules/app'; // 全局的storeimport user from './modules/user'; // 用户信息import permission from './modules/permission'; // 权限import getters from './getters';import &#123; VUEX_DEFAULT_CONFIG &#125; from '@/config'; // vuex 默认配置Vue.use(Vuex);export default new Vuex.Store(&#123; ...VUEX_DEFAULT_CONFIG, modules: &#123; app, user, permission &#125;, getters&#125;); 全局的store@/store/modules/app.js: 12345678910111213141516171819202122232425import &#123; getHomeRoute, getBreadCrumbList &#125; from '@/utils'; // 获取主页、面包屑import &#123; HOME_NAME &#125; from '../../config'; // 主页name，默认dashboardconst app = &#123; state: &#123; globalMenuList: [], // 全局菜单 breadCrumbList: [], // 面包屑 homeRoute: &#123;&#125; //主页，这里默认是dashboard &#125;, mutations: &#123; SET_GLOBAL_MENU: (state, menuList) =&gt; &#123; state.globalMenuList = menuList; &#125;, // 设置面包屑 SET_BREAD_CRUMB(state, route) &#123; state.breadCrumbList = getBreadCrumbList(route, state.homeRoute); &#125;, // 设置主页路由 SET_HOME_ROUTE(state, routes) &#123; state.homeRoute = getHomeRoute(routes, HOME_NAME); &#125; &#125;&#125;;export default app; 权限@/store/modules/permission.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import &#123; asyncRouterMap, constantRouterMap &#125; from '@/router/modules/smart-assistant-jgpt'; // 引入所有的路由/** * @param urlList // 当前用户具备的路由表 * @param route // 待检查的route对象 */function hasPermission(urlList, route) &#123; if (route.meta.noControl) return true; //该页面不需要权限控制 return urlList.includes(route.meta.fullPath);&#125;/** * 递归过滤异步路由表，返回符合用户角色权限的路由表 * @param routes asyncRouterMap 所有有待权限认证的路由配置 * @param routeList 当前用户具备的路由表 */function filterAsyncRouter(routes, urlList) &#123; const res = []; routes.forEach(route =&gt; &#123; const tmp = &#123; ...route &#125;; if (hasPermission(urlList, tmp)) &#123; if (tmp.children) &#123; tmp.children = filterAsyncRouter(tmp.children, urlList); &#125; res.push(tmp); &#125; &#125;); return res;&#125;const permission = &#123; state: &#123; routers: constantRouterMap, addRouters: [], addUrlList: [] &#125;, mutations: &#123; SET_ROUTERS: (state, routers) =&gt; &#123; state.addRouters = routers; state.routers = constantRouterMap.concat(routers); &#125;, SET_ADD_URLLIST: (state, urlList) =&gt; &#123; state.addUrlList = urlList; &#125; &#125;, actions: &#123; GenerateRoutes(&#123; state, commit &#125;, routeList) &#123; return new Promise(resolve =&gt; &#123; let urlList = []; routeList.forEach(item =&gt; &#123; urlList.push(item.resourceUrl); &#125;); let accessedRouters = filterAsyncRouter(asyncRouterMap, urlList); // 动态的控制左侧菜单的 显示隐藏 commit('SET_ROUTERS', accessedRouters); commit('SET_ADD_URLLIST', urlList); resolve(); &#125;); &#125; &#125;&#125;;export default permission; 用户信息@/store/modules/user.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import api from '@/plugins/api';import &#123; getToken, setToken, removeToken &#125; from '@/utils/auth'; // token操作import &#123; treeToList, isEmpty &#125; from '@/utils'; // 工具函数import router from '@/router';import bus from '@/plugins/eventbus';import iView from 'iview';let errorCount = 0; // 登录超过3次输入验证码const user = &#123; state: &#123; user: '', status: '', code: '', token: getToken(), userName: '', avatar: '', introduction: '', roles: [], // role对象具备该用户下面的menuList currentRole: '' &#125;, // mutation默认是全局的 mutations: &#123; SET_CODE: (state, code) =&gt; &#123; state.code = code; &#125;, SET_TOKEN: (state, token) =&gt; &#123; state.token = token; &#125;, SET_INTRODUCTION: (state, introduction) =&gt; &#123; state.introduction = introduction; &#125;, SET_STATUS: (state, status) =&gt; &#123; state.status = status; &#125;, SET_USER_NAME: (state, name) =&gt; &#123; state.userName = name; &#125;, SET_AVATAR: (state, avatar) =&gt; &#123; state.avatar = avatar; &#125;, SET_ROLES: (state, roles) =&gt; &#123; state.roles = roles; &#125;, SET_CURRENT_ROLE: (state, role) =&gt; &#123; state.currentRole = role; // 设置当前系统使用角色 sessionStorage.setItem('currentRoleId', role.id); // 角色的id 保存在当前会话 &#125; &#125;, // actions中可以使用 async函数 // actions使用 大驼峰命名 actions: &#123; // 用户名登录 LoginByUsername(&#123; commit &#125;, userInfo) &#123; return new Promise((resolve, reject) =&gt; &#123; api['login/login'](&#123; ...userInfo &#125;) .then(data =&gt; &#123; commit('SET_TOKEN', data); commit('SET_USER_NAME', userInfo.username); //保存登录的 [用户名] setToken(data); // Cookie本地缓存token errorCount = 0; // 登录成功清除错误次数 resolve(); &#125;) .catch(err =&gt; &#123; errorCount++; if (errorCount &gt;= 3) &#123; bus.$emit('login-error-handler'); // 展示验证码 &#125; // 进行错误处理 reject(err); &#125;); &#125;); &#125;, // 获取用户信息 角色及对应的路由表 在路由的钩子中调用 async GetUserInfo(&#123; commit, state, dispatch &#125;) &#123; await api['user/getRolePermission']().then(data =&gt; &#123; if (isEmpty(data)) &#123; throw new Error('getRolePermission: getRolePermission must be a non-null array !'); &#125; else &#123; // 注意这里的角色data 是数组 用户对应多个角色 commit('SET_ROLES', data); let roleId = sessionStorage.getItem('currentRoleId'); if (roleId) &#123; let roleObj = data.find(item =&gt; &#123; return item.id == roleId; &#125;); if (roleObj) &#123; commit('SET_CURRENT_ROLE', roleObj); &#125; else &#123; throw new Error('用户的同名的角色id值前后不一致'); &#125; &#125; else &#123; // 默认使用第一个权限 作为默认权限 commit('SET_CURRENT_ROLE', data[0]); &#125; &#125; &#125;); // 获取全局菜单 let allRouteList = await api['user/globalMenuResource']().then(data =&gt; &#123; if (isEmpty(data)) &#123; throw new Error('globalMenuResource: globalMenuResource must be a non-null array !'); &#125; else &#123; return data; &#125; &#125;); commit('SET_GLOBAL_MENU', allRouteList); //设置全局菜单 return allRouteList; &#125;, // 后端 登出 async LogOut(&#123; commit &#125;) &#123; try &#123; await api['login/logout'](); commit('SET_TOKEN', ''); commit('SET_ROLES', []); removeToken(); sessionStorage.removeItem('currentRoleId'); router.push(&#123; name: 'login' &#125;); &#125; catch (e) &#123; iView.Message.error('Vuex-LogOut:退出服务接口报错'); &#125; &#125;, // 前端 登出 FedLogOut(&#123; commit &#125;) &#123; return new Promise(resolve =&gt; &#123; commit('SET_TOKEN', ''); removeToken(); sessionStorage.removeItem('currentRoleId'); resolve(); router.push(&#123; name: 'login' &#125;); &#125;); &#125;, //动态的改变 用户权限 修改左侧的菜单 ChangeRoles(&#123; state, commit, dispatch &#125;, role) &#123; let routeList; if (role) &#123; commit('SET_CURRENT_ROLE', role); routeList = role.resourceVOS; //该角色能够访问的菜单 &#125; else &#123; routeList = state.currentRole.resourceVOS; &#125; let urlList = treeToList(routeList); dispatch('GenerateRoutes', urlList); &#125; &#125;&#125;;export default user; getRolePermission接口给的返回数据格式： getters@/store/getters.js: 123456789101112131415const getters = &#123; globalMenuList: state =&gt; state.app.globalMenuList, // 全局的菜单列表 token: state =&gt; state.user.token, avatar: state =&gt; state.user.avatar, name: state =&gt; state.user.userName, introduction: state =&gt; state.user.introduction, status: state =&gt; state.user.status, roles: state =&gt; state.user.roles, // 当前用户具备的权限角色 currentRole: state =&gt; state.user.currentRole, // 当使用的用户角色 permission_routers: state =&gt; state.permission.routers, // 完成的路由表 addRouters: state =&gt; state.permission.addRouters, // 动态添加的路由权限 const+动态获取 addUrlList: state =&gt; state.permission.addUrlList, // 动态获取 breadCrumbList: state =&gt; state.app.breadCrumbList //面包屑&#125;;export default getters; router入口@/router/idnex.js: 12345678910111213141516171819import Vue from 'vue';import Router from 'vue-router';import &#123; constantRouterMap &#125; from './modules/smart-assistant-jgpt'; // 不需要验证用户的权限import &#123; ROUTER_DEFAULT_CONFIG &#125; from '@/config'; // Router 默认配置import &#123; routerBeforeEachFunc, routerAfterEachFunc &#125; from '@/config/interceptor/router'; // 路由拦截器Vue.use(Router);let routerInstance = new Router(&#123; ...ROUTER_DEFAULT_CONFIG, routes: constantRouterMap&#125;);// 注入拦截器routerInstance.beforeEach(routerBeforeEachFunc);routerInstance.afterEach(routerAfterEachFunc);export default routerInstance; 模块@/router/modules/smart-assistant-jgpt/idnex.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import Main from '@/views/smart-assistant-jgpt/main'; // 进入平台后的默认首页import DefaultPage from '@/views/smart-assistant-jgpt/default';import Dashboard from '@/views/dashboard'; // 主页import Login from '@/views/login';import NoPermissionPage from '@/views/error-page/401';import schoolCount from './school-count';// 这些模块 不需要验证用户的权限export const constantRouterMap = [ &#123; path: '/', name: 'dashboard', meta: &#123; title: '主页', noControl: true, headerConfig: &#123; isStartFlag: true &#125;, hideInMenu: true, icon: 'ios-home', by: 'author' &#125;, component: Dashboard &#125;, &#123; path: '/login', name: 'login', meta: &#123; title: '登录', hideInMenu: true, noControl: true, by: 'author' &#125;, component: Login &#125;, &#123; path: '/401', name: '401', meta: &#123; title: '未授权', noControl: true, by: 'author', hideInMenu: true &#125;, component: NoPermissionPage &#125;];/** * meta name * meta title 供左侧菜单展示 * meta hideInMenu 不在左侧菜单展示 * meta showAlways 就算只有1个子 也展示成下拉列表框 * meta noControl 不需要 验证角色的权限 直接保存到路由中 * meta icon 设置图标的名称 * meta headerConfig 供自定义的header组件使用 *///需要进行 权限验证的模块export const asyncRouterMap = [ &#123; // 进入平台后的默认首页 path: '/jgpt', name: 'jgpt', meta: &#123; title: '监管平台', noControl: true, hideInMenu: true, by: 'author' &#125;, redirect: '/jgpt/index', component: Main, children: [ &#123; path: '/jgpt/index', name: 'index', meta: &#123; title: '监管平台', noControl: true, hideInMenu: true, by: 'author' &#125;, component: DefaultPage &#125; ] &#125;, schoolCount // 业务模块]; 列举其中一个模块写法： @/router/modules/smart-assistant-jgpt/school-count.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import Main from '@/views/smart-assistant-jgpt/main';/** * /jgpt/schoolCount 学校统计 * -- /jgpt/schoolCount/schoolManage 学校管理 * -- /jgpt/schoolCount/schoolContact 学校联系人 */export default &#123; // 学校统计信息 path: '/jgpt/schoolCount', name: 'schoolCount', meta: &#123; fullPath: '/jgpt/schoolCount', title: '学校统计', icon: 'ios-paper', showAlways: true &#125;, component: Main, children: [ &#123; path: '/jgpt/schoolCount/schoolManage', name: 'schoolManage', meta: &#123; title: '学校管理', fullPath: '/jgpt/schoolCount/schoolManage', by: 'author' &#125;, component: resovle =&gt; require(['@/views/smart-assistant-jgpt/school-count/school-manage'], resovle) &#125;, &#123; path: '/jgpt/schoolCount/schoolManager/schoolDetail', name: 'schoolDetail', meta: &#123; title: '学校详情', fullPath: '/jgpt/schoolCount/schoolManager/schoolDetail', noControl: true, hideInMenu: true, by: 'author' &#125;, component: resovle =&gt; require(['@/views/smart-assistant-jgpt/school-count/school-manage/subpage/school-detail'], resovle) &#125;, &#123; path: '/jgpt/schoolCount/schoolContact', name: 'schoolContact', meta: &#123; title: '学校联系人', fullPath: '/jgpt/schoolCount/schoolContact', by: 'author' &#125;, component: resovle =&gt; require(['@/views/smart-assistant-jgpt/school-count/school-contact'], resovle) &#125;, &#123; path: '/jgpt/schoolCount/schoolContact/contactDetail', name: 'contactDetail', meta: &#123; title: '联系人详情', fullPath: '/jgpt/schoolCount/schoolContact/contactDetail', noControl: true, hideInMenu: true, by: 'author' &#125;, component: resovle =&gt; require(['@/views/smart-assistant-jgpt/school-count/school-contact/subpage/contact-detail'], resovle) &#125; ]&#125;; 路由拦截器@/config/interceptor/router.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import router from '@/router';import store from '@/store';import &#123; getToken &#125; from '@/utils/auth'; // getToken from cookieimport &#123; treeToList &#125; from '../../utils';import iView from 'iview';//设置加载条的高度iView.LoadingBar.config(&#123; height: 3&#125;);function hasPermission(urlList, to) &#123; if (to.meta.noControl) return true; return urlList.includes(to.path || to.meta.fullPath);&#125;const whiteList = ['/login']; // no redirect whitelistexport function routerBeforeEachFunc(to, from, next) &#123; iView.LoadingBar.start(); if (to.meta.title) &#123; document.title = to.meta.title; &#125; window.currentRoute = to; //保存当前的路由,功能按钮权限访问 if (getToken()) &#123; // determine if there has token是否登录 使用本地缓存Cookie /* has token 已经登录了访问login 直接跳转到 dashboard*/ if (to.path === '/login') &#123; next(&#123; path: '/' &#125;); iView.LoadingBar.finish(); //hack 技巧 if current page is dashboard will not trigger afterEach hook, so manually handle it &#125; else &#123; // 每次刷新 都重新的获取权限 if (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完user_info信息 store .dispatch('GetUserInfo') .then(res =&gt; &#123; // 获取全局的菜单 const routeTreeData = res; let routeList = treeToList(routeTreeData); // 对比代码配置的路由对象 与服务器点返回的路由 生成路由表 store.dispatch('GenerateRoutes', routeList).then(() =&gt; &#123; // 根据roles权限生成可访问的路由表 router.addRoutes(store.getters.addRouters); // 动态添加可访问路由表 // 以由当前用角色 改变[左侧渲染菜单] store.dispatch('ChangeRoles'); // 下次再进入路由时候 直接走else进入到动态添加的路由中 next(&#123; ...to, replace: true &#125;); // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record &#125;); &#125;) .catch(err =&gt; &#123; store.dispatch('FedLogOut').then(() =&gt; &#123; iView.Message.error('获取角色信息失败,请重新登录'); next(&#123; path: '/' &#125;); &#125;); &#125;); &#125; else &#123; // 没有动态的改变权限则直接进入 // next(); // 改变角色会改变vuex保存的路由，所以这里要判断 if (hasPermission(store.getters.addUrlList, to)) &#123; next(); &#125; else &#123; // 进入未授权的页面 next(&#123; path: '/401', replace: true, query: &#123; noGoBack: true &#125; &#125;); &#125; &#125; &#125; &#125; else &#123; /* has no token*/ // 白名单里面初始化 if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入 next(); &#125; else &#123; next(`/login?redirect=$&#123;to.path&#125;`); // 否则全部重定向到登录页 iView.LoadingBar.finish(); // if current page is login will not trigger afterEach hook, so manually handle it &#125; &#125;&#125;export function routerAfterEachFunc(to, from) &#123; iView.LoadingBar.finish();&#125; Vuex和router配置默认配置@/config/idnex.js: 123456789101112131415// 面包屑的 主页是dashboardexport const HOME_NAME = 'dashboard';// Router 默认配置export const ROUTER_DEFAULT_CONFIG = &#123; mode: 'history', //base: process.env.NODE_ENV !== 'production' ? '/' : '/etsapp/' base: '/'&#125;;// vuex 默认配置 state 只能在mutation中改变export const VUEX_DEFAULT_CONFIG = &#123; strict: process.env.NODE_ENV !== 'production' // strict: false&#125;; 注册@/idnex.js: 123456789101112import Vue from 'vue';import App from './App';import router from '@/router';import store from '@/store';window.app = new Vue(&#123; el: '#app', store, router, render: h =&gt; h(App)&#125;); 面包屑使用方法mixins@/views/mixins/bread-crumb.js: 12345678910111213141516171819202122232425262728293031import &#123; constantRouterMap &#125; from '@/router/modules/smart-assistant-jgpt'; // 不需要验证用户权限的路由import &#123; mapMutations, mapGetters &#125; from 'vuex';/** * * 面包屑 子组件override watch $route 逻辑时拷贝已有的逻辑 */const mixin = &#123; mounted() &#123; this.setHomeRoute(constantRouterMap); // 设置主页 this.setBreadCrumb(this.$route); // 设置面包屑的内容 &#125;, methods: &#123; ...mapMutations(&#123; setHomeRoute: 'SET_HOME_ROUTE', setBreadCrumb: 'SET_BREAD_CRUMB' &#125;) &#125;, computed: &#123; ...mapGetters(['breadCrumbList']) &#125;, // 子组件可以 override这个方法 watch: &#123; $route(newRoute) &#123; this.setBreadCrumb(newRoute); this.$refs.sideMenu &amp;&amp; this.$refs.sideMenu.updateOpenName(newRoute.name); &#125; &#125;&#125;;export default mixin; @/views/mixins/index.js: 12import BreadCrumb from './bread-crumb';export &#123; BreadCrumb &#125;; 组件@/components/custom-bread-crumb/custom-bread-crumb.vue: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class=&quot;custom-bread-crumb&quot;&gt; &lt;Breadcrumb :style=&quot;&#123;fontSize: `$&#123;fontSize&#125;px`&#125;&quot;&gt; &lt;BreadcrumbItem v-for=&quot;item in list&quot; :to=&quot;item.to&quot; :key=&quot;`bread-crumb-$&#123;item.name&#125;`&quot;&gt; &lt;common-icon style=&quot;margin-right: 4px;&quot; :type=&quot;item.icon || &apos;&apos;&quot; :size=&quot;20&quot;/&gt; &#123;&#123; showTitle(item) &#125;&#125; &lt;/BreadcrumbItem&gt; &lt;template v-if=&quot;breadCrumbTitle instanceof Array &amp;&amp; breadCrumbTitle.length&gt;0&quot;&gt; &lt;BreadcrumbItem v-for=&quot;item in breadCrumbTitle&quot; :key=&quot;`bread-crumb-$&#123;item.name&#125;`&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/BreadcrumbItem&gt; &lt;/template&gt; &lt;/Breadcrumb&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; showTitle &#125; from &apos;@/utils&apos;;import CommonIcon from &apos;@/components/common-icon&apos;;import &apos;./custom-bread-crumb.less&apos;;export default &#123; name: &apos;customBreadCrumb&apos;, components: &#123; CommonIcon &#125;, props: &#123; list: &#123; type: Array, default: () =&gt; [] &#125;, fontSize: &#123; type: Number, default: 14 &#125;, showIcon: &#123; type: Boolean, default: false &#125;, breadCrumbTitle: &#123; //自定义面包屑 type: Array, default: function() &#123; return []; &#125; &#125; &#125;, methods: &#123; showTitle(item) &#123; return showTitle(item, this); &#125; &#125;&#125;;&lt;/script&gt; @/components/custom-bread-crumb/custom-bread-crumb.less: 1234.custom-bread-crumb&#123; display: inline-block; vertical-align: top;&#125; @/components/custom-bread-crumb/index.js: 12import customBreadCrumb from './custom-bread-crumb.vue';export default customBreadCrumb; @/components/common-icon/common-icon.vue: 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;component :is=&quot;iconType&quot; :type=&quot;iconName&quot; :color=&quot;iconColor&quot; :size=&quot;iconSize&quot;/&gt;&lt;/template&gt;&lt;script&gt;import Icons from &apos;../icons&apos;;export default &#123; name: &apos;CommonIcon&apos;, components: &#123; Icons &#125;, props: &#123; type: &#123; type: String, required: true &#125;, color: String, size: Number &#125;, computed: &#123; iconType() &#123; return this.type.indexOf(&apos;_&apos;) === 0 ? &apos;Icons&apos; : &apos;Icon&apos;; &#125;, iconName() &#123; return this.iconType === &apos;Icons&apos; ? this.getCustomIconName(this.type) : this.type; &#125;, iconSize() &#123; return this.size || (this.iconType === &apos;Icons&apos; ? 12 : undefined); &#125;, iconColor() &#123; return this.color || &apos;&apos;; &#125; &#125;, methods: &#123; getCustomIconName(iconName) &#123; return iconName.slice(1); &#125; &#125;&#125;;&lt;/script&gt; @/components/common-icon/index.js: 12import CommonIcon from './common-icon.vue';export default CommonIcon; 无扩展项目时123&lt;div class="navigation"&gt; &lt;CustomBreadCrumb :list="breadCrumbList"&gt;&lt;/CustomBreadCrumb&gt;&lt;/div&gt; 12345678import &#123; BreadCrumb &#125; from '@/views/mixins';import CustomBreadCrumb from '@/components/custom-bread-crumb';mixins: [ BreadCrumb] components: &#123; CustomBreadCrumb&#125; 有扩展项目时1&lt;CustomBreadCrumb :list="breadCrumbList" :breadCrumbTitle="breadCrumbTitle"&gt;&lt;/CustomBreadCrumb&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; BreadCrumb &#125; from '@/views/mixins';import CustomBreadCrumb from '@/components/custom-bread-crumb';mixins: [ BreadCrumb] components: &#123; CustomBreadCrumb&#125;data() &#123; return &#123; breadCrumbTitle: [], // 面包屑扩展项目 breadTile: &#123; LOOK: [ &#123; id: 1, name: '查看' &#125; ], EDIT: [ &#123; id: 2, name: '修改' &#125; ] &#125;, &#125;&#125;watch: &#123; $route: &#123; handler: function(value) &#123; this.breadCrumbTitle = []; // 清空面包屑扩展项目 if ('schoolDetail' === value.name) &#123; const &#123; detailState &#125; = value.query; this.breadCrumbTitle = this.breadTile[detailState]; this.breadCrumbTitle = this.breadTile[detailState]; &#125; &#125;, immediate: true &#125;,&#125; 工具函数@/utils/index.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @param &#123;Array&#125; routers 路由列表数组 * @description 用于找到路由列表中name为home的对象 */export const getHomeRoute = (routers, homeName = 'dashboard') =&gt; &#123; let i = -1; let len = routers.length; let homeRoute = &#123;&#125;; while (++i &lt; len) &#123; let item = routers[i]; if (item.children &amp;&amp; item.children.length) &#123; let res = getHomeRoute(item.children, homeName); if (res.name) return res; &#125; else &#123; if (item.name === homeName) homeRoute = item; &#125; &#125; return homeRoute;&#125;;/** * @param &#123;Array&#125; routeMetched 当前路由metched * @returns &#123;Array&#125; */export const getBreadCrumbList = (route, homeRoute) =&gt; &#123; let homeItem = &#123; ...homeRoute, icon: homeRoute.meta.icon &#125;; let routeMetched = route.matched; if (routeMetched.some(item =&gt; item.name === homeRoute.name)) return [homeItem]; let res = routeMetched .filter(item =&gt; &#123; return item.meta === undefined || !item.meta.hideInBread; // 过滤掉面包屑隐藏的 &#125;) .map(item =&gt; &#123; let meta = &#123; ...item.meta &#125;; if (meta.title &amp;&amp; typeof meta.title === 'function') &#123; meta.__titleIsFunction__ = true; meta.title = meta.title(route); &#125; let obj = &#123; icon: (item.meta &amp;&amp; item.meta.icon) || '', name: item.name, meta: meta &#125;; return obj; &#125;); //hide in menu的不过滤 // res = res.filter(item =&gt; &#123; // return !item.meta.hideInMenu; // &#125;); // home 可以跳转 return [&#123; ...homeItem, to: homeRoute.path &#125;, ...res];&#125;;export function treeToList(routeList) &#123; let res = []; function foo(nodeData) &#123; let &#123; resourceName, resourceUrl, children, actionVOS &#125; = nodeData; // 过滤掉 resourceUrl是null的选项 if (resourceUrl) res.push(&#123; resourceName, resourceUrl, actionVOS &#125;); // children 挂载的是子节点 if (!isEmpty(children)) &#123; children.forEach(item =&gt; &#123; foo(item); &#125;); &#125; &#125; routeList.forEach(item =&gt; &#123; foo(item); &#125;); return res;&#125;//判断空数组，null,undefined,空字符串,空对象export function isEmpty(obj) &#123; //基础数据类型，是非空值 if (typeof obj === 'boolean' || typeof obj === 'number') &#123; return false; &#125; if ( obj == '' || obj == null || obj == undefined || (obj &amp;&amp; Array.isArray(obj) &amp;&amp; !obj.length) || (obj &amp;&amp; Object.keys(obj).length === 0) ) &#123; return true; &#125; else &#123; return false; &#125;&#125;export const showTitle = (item, vm) =&gt; &#123; let &#123; title, __titleIsFunction__ &#125; = item.meta; if (!title) return; title = (item.meta &amp;&amp; item.meta.title) || item.name; return title;&#125;; @/utils/auth.js: 123456789101112131415import Cookies from 'js-cookie';const TokenKey = 'Admin-Token';export function getToken() &#123; return Cookies.get(TokenKey);&#125;export function setToken(token) &#123; return Cookies.set(TokenKey, token);&#125;export function removeToken() &#123; return Cookies.remove(TokenKey);&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iView常见全局样式]]></title>
    <url>%2F2019%2F01%2F23%2FiView%E5%B8%B8%E8%A7%81%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[记录常用的全局样式写法 手动在form-item前加上红色*，表示必填项123456789.ivu-form-item-required .ivu-form-item-label::before &#123; content: '*'; display: inline-block; margin-right: 4px; line-height: 1; font-family: SimSun; font-size: 12px; color: #ed3f14;&#125; form-item上定义类ivu-form-item-required 多余文字省略12345.text-overflow &#123; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;&#125; 表格行高1234/*表格高度改为35ps*/.ivu-table td &#123; height: 35px;&#125; 表格无数据时的默认图片1234567891011/* 表格没有数据时的默认图片 */.ivu-table-tip table td span &#123; background: url("../../assets/images/tableDataEmpty.png"); padding-bottom: 50px; display: inline-block; padding-top: 160px; color: #aaaaaa; background-repeat: no-repeat; background-position: center 40px; min-width: 200px;&#125; 表格表头12345678910111213141516171819/*表格表头*/table th .ivu-table-cell &#123; position: relative; display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-left: 10px; padding-right: 10px; span &#123; margin-top: -2px; &#125; .ivu-table-sort &#123; margin-top: -6px; position: absolute; top: 50%; right: 5px; &#125;&#125; 表格公共样式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//表格公共样式.tableInfoBox &#123; position: relative; margin: 10px 0px 0px; .baseBorder(); background-color: #fff; .ivu-table-wrapper &#123; border: 0px; &#125; .ivu-table-border th, .ivu-table-border td &#123; border-color: @baseBorderColor; &#125; .ivu-table-border th:last-child, .ivu-table-border td:last-child &#123; border-right: 0px; &#125; .ivu-table:after &#123; width: 0px; &#125; .ivu-table:before &#123; height: 0px; &#125; .ivu-table table &#123; width: calc(~'100% - '0px) !important; &#125; .ivu-table-tip td &#123; border-bottom: 0px; span &#123; width: 100%; padding: 0px; background: url("../../assets/images/tableNoneData.png"); display: inline-block; color: #aaaaaa; background-repeat: no-repeat; background-position: center 50%; &#125; &#125; .webPage &#123; position: absolute; bottom: 0px; left: 0px; right: 0px; height: 70px; text-align: center; padding: 18px 0px; background: #fff; &#125; &amp;.hasDataAndPage &#123; padding-bottom: 70px; &#125;&#125; 弹窗居中显示123456789/*-弹窗居中显示-*/.vertical-center-modal &#123; display: flex; align-items: center; justify-content: center; .ivu-modal &#123; top: 0; &#125;&#125; 不可点击1234.look &#123; pointer-events: none; outline: none;&#125; 注意input还需加readonly，否则双击还是可编辑 form-item框和字变红1234567891011.red &#123; .ivu-input.ivu-input-default &#123; color: red; &#125; .ivu-select.ivu-select-single.ivu-select-default &#123; color: red; &#125; .ivu-form-item-label &#123; color: red; &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[发送图文消息]]></title>
    <url>%2F2019%2F01%2F23%2F%E5%8F%91%E9%80%81%E5%9B%BE%E6%96%87%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[需求：点击选择图片或拖拽选择图片（均可多选）。可输入文字，最终经后台发给app端，因此需保留顺序和布局信息，将参数格式化。 模板： 12345678910111213141516171819&lt;FormItem label=&quot;消息内容:&quot; class=&quot;ivu-form-item-required&quot;&gt; &lt;div style=&quot;word-wrap: break-word;white-space : normal;&quot;&gt; &lt;div class=&quot;config-point-ipt set-item-content contentLengthNotice&quot; style=&quot;height:200px; overflow-y:auto;&quot; id=&quot;content&quot; contenteditable=&quot;true&quot; name=&quot;content&quot; @keyup=&quot;removeBackgroundImage&quot; @dragenter=&quot;ignoreDrag&quot; @dragover=&quot;ignoreDrag&quot; @drop=&quot;drop&quot;&gt; &lt;/div&gt; &lt;p v-if=&quot;!hasContent&quot; style=&quot;color:#c7c1c1;position:absolute;bottom:205px;left:20px;pointer-events: none;&quot;&gt; 请输入消息内容，最多不超过1000字 &lt;/p&gt; &lt;form id=&quot;myForm&quot;&gt; &lt;input @change=&quot;chooseImage&quot; multiple type=&quot;file&quot; accept=&quot;image/jpeg,image/x-png,image/gif&quot; id=&quot;&quot; value=&quot;&quot; style=&quot;width:64px&quot;/&gt; &lt;/form&gt; &lt;span style=&quot;color: #7070dc;font-size:5px;font-style:italic;&quot;&gt; Tips:您可通过点击左侧添加图片，亦可从本地文件夹向消息内容框拖放图片 &lt;/span&gt; &lt;/div&gt;&lt;/FormItem&gt;&lt;FormItem&gt; &lt;Button type=&quot;primary&quot; @click=&quot;sendHandler&quot;&gt;确定发送&lt;/Button&gt;&lt;/FormItem&gt; 123456// 拖拽进入事件,拖拽移动事件ignoreDrag(e) &#123; // 确保其他元素不会取得该事件 e.stopPropagation(); e.preventDefault();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 拖拽放下事件drop(e) &#123; this.hasContent = true; e.stopPropagation(); e.preventDefault(); let contentEl = document.querySelector('#content'); contentEl.focus(); //去掉背景图片 if (contentEl.classList.contains('contentLengthNotice')) &#123; contentEl.classList.remove('contentLengthNotice'); &#125; let _this = this; let files = e.dataTransfer.files; for (let i = 0; i &lt; files.length; i++) &#123; // 获取File引用: let file = files[i]; if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') &#123; this.Message.error('存在非图片文件，请重新拖选!'); return; &#125; _this.imgLength++; //读取文件: let reader = new FileReader(); reader.onloadend = function() &#123; // 图片的 base64 格式, 可以直接当成 img 的 src 属性值 let dataURL = reader.result; let imgEle = document.createElement('img'); imgEle.setAttribute('src', dataURL); imgEle.setAttribute('alt', file.name); imgEle.setAttribute( 'id', file.name.substring(0, file.name.lastIndexOf('.')) + '_' + _this.imgLength + file.name.substring(file.name.lastIndexOf('.')) ); // 获取真实宽高 let img = new Image(); img.src = dataURL; img.onload = function() &#123; let width = img.width; let height = img.height; let win = contentEl.ownerDocument.defaultView; let contentWidth = win.getComputedStyle(contentEl, null).width; let contentPaddingLeft = win.getComputedStyle(contentEl, null).paddingLeft; let contentBorderLeftWidth = win.getComputedStyle(contentEl, null).borderLeftWidth; let preEleWidth = parseInt(contentWidth) - 2 * parseInt(contentBorderLeftWidth) - 2 * parseInt(contentPaddingLeft); if (width &gt; preEleWidth) &#123; imgEle.style.width = preEleWidth; imgEle.style.heigth = (preEleWidth * height) / width + 'px'; &#125; else &#123; imgEle.style.width = width; imgEle.style.heigth = height + 'px'; &#125; window.document.execCommand('InsertHtml', '', imgEle.outerHTML); &#125;; &#125;; //以DataURL的形式读取文件: reader.readAsDataURL(file); &#125;&#125; 1234567891011121314151617181920// 输入时事件removeBackgroundImage() &#123; let contentEl = document.querySelector('#content'); this.contentText = contentEl.innerText; if (this.contentText.length &gt;= 1000) &#123; this.$Message.error('内容不能超过1000字'); &#125; if (contentEl.innerHTML) &#123; this.hasContent = true; &#125; else &#123; this.hasContent = false; &#125; if (contentEl.classList.contains('contentLengthNotice')) &#123; contentEl.classList.remove('contentLengthNotice'); &#125; if (!contentEl.innerHTML &amp;&amp; !contentEl.classList.contains('contentLengthNotice')) &#123; contentEl.classList.add('contentLengthNotice'); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 选择文件chooseImage(e) &#123; this.hasContent = true; let _this = this; let contentEl = document.querySelector('#content'); contentEl.focus(); // 读取文件 let files = e.target.files; for (let i = 0; i &lt; files.length; i++) &#123; let file = files[i]; _this.imgLength++; let reader = new FileReader(); reader.readAsDataURL(file); // 读出 base64 reader.onloadend = function() &#123; // 图片的 base64 格式, 可以直接当成 img 的 src 属性值 let dataURL = reader.result; let contentEl = document.querySelector('#content'); let imgEle = document.createElement('img'); imgEle.setAttribute('src', dataURL); imgEle.setAttribute('alt', file.name); imgEle.setAttribute( 'id', file.name.substring(0, file.name.lastIndexOf('.')) + '_' + _this.imgLength + file.name.substring(file.name.lastIndexOf('.')) ); // 获取真实宽高 let img = new Image(); img.src = dataURL; img.onload = function() &#123; let width = img.width; let height = img.height; let win = contentEl.ownerDocument.defaultView; let contentWidth = win.getComputedStyle(contentEl, null).width; let contentPaddingLeft = win.getComputedStyle(contentEl, null).paddingLeft; let contentBorderLeftWidth = win.getComputedStyle(contentEl, null).borderLeftWidth; let preEleWidth = parseInt(contentWidth) - 2 * parseInt(contentBorderLeftWidth) - 2 * parseInt(contentPaddingLeft); if (width &gt; preEleWidth) &#123; imgEle.style.width = preEleWidth; imgEle.style.heigth = (preEleWidth * height) / width + 'px'; &#125; else &#123; imgEle.style.width = width; imgEle.style.heigth = height + 'px'; &#125; window.document.execCommand('InsertHtml', '', imgEle.outerHTML); &#125;; &#125;; &#125; document.getElementById('myForm').reset();&#125; 1234567891011121314151617181920212223242526272829303132333435363738// 发送sendHandler() &#123; let contentEl = document.querySelector('#content'); let imgEles = document.getElementsByTagName('img'); let imgContentArr = []; for (let i = 0; i &lt; imgEles.length; i++) &#123; let obj = &#123;&#125;; obj.imgName = imgEles[i].getAttribute('id'); obj.imgBase64 = imgEles[i].getAttribute('src').substring(imgEles[i].getAttribute('src').indexOf('base64,') + 7); imgEles[i].setAttribute('src', ''); imgContentArr.push(obj); &#125; let txtContent = contentEl.innerHTML.replace(/ src=""/g, ''); if (txtContent === '' &amp;&amp; imgContentArr.length === 0) &#123; this.$Message.error('信息内容不能为空！'); return; &#125; if (contentEl.innerText.length &gt;= 1000) &#123; this.lengthFlag = true; return; &#125; let messageContent = &#123; txtContent: escapeHTML(txtContent), imgContentArr: imgContentArr &#125;; this.$api['sendMessage/send'](&#123; content: messageContent &#125;).then(data =&gt; &#123; this.$Message.success(&#123; content: '发送成功', duration: 3, closable: true &#125;); this.hasContent = false; contentEl.innerHTML = ''; &#125;);&#125; 接口调用方法见axios封装及api调用方法]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[功能点：查看详情后返回，回显搜索条件]]></title>
    <url>%2F2019%2F01%2F23%2F%E5%8A%9F%E8%83%BD%E7%82%B9%EF%BC%9A%E6%9F%A5%E7%9C%8B%E8%AF%A6%E6%83%85%E5%90%8E%E8%BF%94%E5%9B%9E%EF%BC%8C%E5%9B%9E%E6%98%BE%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[首页含有条件搜索和分页，点击某一项跳转页面查看详情后，返回首页，回显搜索条件和分页。 获取首页数据时，保存搜索条件 1234567891011121314151617methods: &#123; saveSearchData() &#123; let searchObj = &#123; provinceId: this.searchData.provinceId, cityId: this.searchData.cityId, districtId: this.searchData.districtId, schoolName: this.searchData.schoolName, page: this.page.index, pageSize: this.page.size &#125;; window.sessionStorage.setItem('schoolSearch', JSON.stringify(searchObj)); &#125;, // 获取数据 loadData() &#123; this.saveSearchData(); &#125;&#125; 离开首页时，若去向不是详情页，清除sessionStorage 123456beforeRouteLeave(to, from, next) &#123; if (to.name !== 'schoolDetail') &#123; sessionStorage.removeItem('schoolSearch'); &#125; next();&#125; 离开详情页时，若去向不是首页，清除sessionStorage 123456beforeRouteLeave(to, from, next) &#123; if (to.name !== 'schoolManage') &#123; sessionStorage.removeItem('schoolSearch'); &#125; next();&#125; 搜索条件和分页回显 没有省市区联动时： 123456789101112131415mounted() &#123; let searchObj = window.sessionStorage.getItem('schoolSearch'); if (searchObj) &#123; let searchData = JSON.parse(searchObj); // 延时的更新，保证 数据 与 UI(渲染一致) setTimeout(() =&gt; &#123; this.searchData.schoolName = searchData.schoolName; this.page.index = searchData.page; this.page.size = searchData.pageSize; this.loadData(this.page.index); &#125;, 500); &#125; else &#123; this.loadData(); &#125;&#125; 有省市区联动时： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859mounted() &#123; let searchObj = window.sessionStorage.getItem('schoolSearch'); if (searchObj) &#123; let searchData = JSON.parse(searchObj); // 延时的更新，保证 数据 与 UI(渲染一致) setTimeout(() =&gt; &#123; if (searchData.provinceId &amp;&amp; !searchData.cityId) &#123; this.searchData.provinceId = searchData.provinceId; this.isDisableCityFlag = false; this.isDisableAreaFlag = true; let queryData = &#123; provinceId: searchData.provinceId &#125;; this.$api['region/listCity'](queryData).then(data =&gt; &#123; this.citySelectData = data; this.searchData.schoolName = searchData.schoolName; this.page.index = searchData.page; this.page.size = searchData.pageSize; this.loadData(this.page.index); &#125;); &#125; if (searchData.provinceId &amp;&amp; searchData.cityId) &#123; this.searchData.provinceId = searchData.provinceId; this.isDisableCityFlag = false; this.isDisableAreaFlag = false; let queryData = &#123; provinceId: searchData.provinceId &#125;; this.$api['region/listCity'](queryData).then(data =&gt; &#123; this.citySelectData = data; this.searchData.cityId = searchData.cityId; let queryData2 = &#123; provinceId: searchData.provinceId, cityId: searchData.cityId &#125;; this.$api['region/listDistrict'](queryData2).then(data2 =&gt; &#123; this.areaSelectData = data2; this.searchData.districtId = searchData.districtId; this.searchData.schoolName = searchData.schoolName; this.page.index = searchData.page; this.page.size = searchData.pageSize; this.loadData(this.page.index); &#125;); &#125;); &#125; if (!searchData.provinceId) &#123; this.searchData.schoolName = searchData.schoolName; this.page.index = searchData.page; this.page.size = searchData.pageSize; this.loadData(this.page.index); &#125; &#125;, 500); &#125; else &#123; this.loadData(); &#125; this.loadMarketRegion(); // this.findProvince(); this.loadProvinceSelectData();&#125;, 1234loadData(pageIndex = 1) &#123; if (pageIndex) this.page.index = pageIndex; ...&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[上传下载文件的几种方法]]></title>
    <url>%2F2019%2F01%2F22%2F%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[总结Vue开发过程中，上传下载文件的几种方法。 下载静态资源下载a标签href指向下载地址，download属性设为空 1&lt;a href="download.com" download=""&gt;下载&lt;/a&gt; 动态渲染render函数写法： 12345678910111213render: (h, params) =&gt; &#123; let download = h( 'a', &#123; attrs: &#123; href: params.row.filePath, download: '' &#125; &#125;, '下载' ); return h('div', &#123;&#125;, [download]);&#125; arraybuffer转blob下载excel封装： 1234567891011121314151617181920function downLoadExcelFile(url, queryString, options = &#123;&#125;) &#123; if (!api[url]) &#123; throw new Error(`不存在该下载接口$&#123;url&#125;`); &#125; let queryOptions = Object.assign(&#123; responseType: 'arraybuffer' &#125;, options); api[url](queryString, queryOptions).then((&#123; data, fileName &#125;) =&gt; &#123; let blob = new Blob([data], &#123; type: 'application/vnd.ms-excel' &#125;); let downloadElement = document.createElement('a'); let href = window.URL.createObjectURL(blob); //创建下载的链接 downloadElement.href = href; downloadElement.download = 'xxx.xlsx'; //下载后文件名 if (fileName) &#123; downloadElement.download = fileName; &#125; document.body.appendChild(downloadElement); downloadElement.click(); //点击下载 document.body.removeChild(downloadElement); //下载完成移除元素 window.URL.revokeObjectURL(href); //释放掉blob对象 &#125;);&#125; 接口调用方法见axios封装及api调用方法 使用： 123456789import &#123; debounce &#125; from '@/utils';exportTeachers: (function() &#123; return debounce(function() &#123; let params = this.searchData; params.roleId = this.roleId; this.$download.downLoadExcelFile('schoolContact/exportTeachers', params); &#125;, 300);&#125;)(), 引入了防抖 新建iframe下载1234567891011121314151617181920let downloadIFrame = null;function createDownloadIFrame() &#123; downloadIFrame = document.createElement('iframe'); downloadIFrame.style.position = 'fixed'; downloadIFrame.style.opacity = '0'; downloadIFrame.style.width = '10px'; downloadIFrame.style.height = '10px'; downloadIFrame.style.left = '-20px'; downloadIFrame.style.top = '-20px'; downloadIFrame.width = '10'; downloadIFrame.height = '10'; document.body.appendChild(downloadIFrame);&#125;//下载文件export function downloadFile(url) &#123; if (!downloadIFrame) &#123; createDownloadIFrame(); &#125; downloadIFrame.src = url ? url : '';&#125; 取接口给的base64格式小图片1234this.$api['login/getLoginImages']().then(data =&gt; &#123; let imgEle = document.getElementById('imageMask'); imgEle.setAttribute('src', 'data:image/gif;base64,' + data);&#125;); 上传formData123456789101112131415161718192021uploadProofMaterial() &#123; let formData = new FormData(); formData.append('roleId', this.roleId); this.fileList.forEach(item =&gt; &#123; formData.append('files', item); &#125;); formData.append('teacherId', '1'); this.$api['schoolContact/uploadProofMaterial'](formData, &#123; headers: &#123; 'Content-Type': 'multipart/form-data' &#125;, timeout: 60000 &#125;) .then(() =&gt; &#123; this.$Message.success('举证材料上传成功!'); this.editSuccessFlag = true; &#125;) .catch(() =&gt; &#123; this.$Message.error('举证材料上传失败请重试!'); &#125;)&#125; FormData 接口的append()方法 会添加一个新值到 FormData 对象内的一个已存在的键中，如果键不存在则会添加该键。 12formData.get("k1"); // "v1"formData.getAll("k1"); // ["v1","v2","v3"] base64上传小图片1234&lt;form id=&quot;myForm&quot;&gt; &lt;input @change=&quot;chooseImage&quot; type=&quot;file&quot; accept=&quot;image/jpeg,image/x-png,image/gif&quot; id=&quot;&quot; value=&quot;&quot;/&gt;&lt;/form&gt;&lt;img id=&quot;imageMask&quot; src=&quot;&quot;&gt; 12345678910111213141516171819// 选择文件chooseImage(e) &#123; this.hasContent = true; let _this = this; let contentEl = document.querySelector('#content'); contentEl.focus(); // 读取文件 let files = e.target.files; let file = files[0]; let reader = new FileReader(); reader.readAsDataURL(file); // 读出 base64 reader.onloadend = function() &#123; // 图片的 base64 格式, 可以直接当成 img 的 src 属性值 let dataURL = reader.result; let imgEle = document.getElemetnById('imageMask'); imgEle.setAttribute('src', dataURL); &#125;; document.getElementById('myForm').reset();&#125;, 参考：发送图文消息]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[省市区联动组件]]></title>
    <url>%2F2019%2F01%2F22%2F%E7%9C%81%E5%B8%82%E5%8C%BA%E8%81%94%E5%8A%A8%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[系统中经常用到的省市区联动 mixins@/utils/views/mixins/region.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export default &#123; data() &#123; return &#123; isDisableCityFlag: true, isDisableAreaFlag: true, provinceSelectData: [], citySelectData: [], areaSelectData: [] &#125;; &#125;, methods: &#123; //加载 省数据 loadProvinceSelectData() &#123; this.$api['region/listProvince']().then(data =&gt; &#123; this.provinceSelectData = data; &#125;); &#125;, provinceChangeHandler(provinceId) &#123; this.citySelectData = []; this.areaSelectData = []; this.searchData.cityId = ''; this.searchData.districtId = ''; if (provinceId) &#123; this.isDisableCityFlag = false; this.isDisableAreaFlag = true; let queryData = &#123; provinceId &#125;; this.$api['region/listCity'](queryData).then(data =&gt; &#123; this.citySelectData = data; &#125;); &#125; else &#123; this.isDisableCityFlag = true; this.isDisableAreaFlag = true; &#125; &#125;, cityChangeHandler(cityId) &#123; this.areaSelectData = []; this.searchData.districtId = ''; if (cityId) &#123; this.isDisableAreaFlag = false; let queryData = &#123; provinceId: this.searchData.provinceId, cityId &#125;; this.$api['region/listDistrict'](queryData).then(data =&gt; &#123; this.areaSelectData = data; &#125;); &#125; else &#123; this.isDisableAreaFlag = true; &#125; &#125; &#125;&#125;; 接口调用方法见axios封装及api调用方法 使用index.vue: 模板： 1234567891011121314151617181920212223242526272829303132333435&lt;FormItem label=&quot;省: &quot;&gt; &lt;Select v-model=&quot;searchData.provinceId&quot; placeholder=&quot;全部&quot; @on-change=&quot;provinceChangeHandler&quot;&gt; &lt;Option value=&quot;&quot;&gt;全部&lt;/Option&gt; &lt;Option v-for=&quot;item in provinceSelectData&quot; :key=&quot;item.provinceId&quot; :value=&quot;item.provinceId&quot;&gt; &#123;&#123;item.provinceName&#125;&#125; &lt;/Option&gt; &lt;/Select&gt;&lt;/FormItem&gt;&lt;FormItem label=&quot;市: &quot;&gt; &lt;Select v-model=&quot;searchData.cityId&quot; placeholder=&quot;全部&quot; @on-change=&quot;cityChangeHandler&quot; :disabled=&quot;isDisableCityFlag&quot;&gt; &lt;Option value=&quot;&quot;&gt;全部&lt;/Option&gt; &lt;Option v-for=&quot;item in citySelectData&quot; :key=&quot;item.cityId&quot; :value=&quot;item.cityId&quot;&gt; &#123;&#123;item.cityName&#125;&#125; &lt;/Option&gt; &lt;/Select&gt;&lt;/FormItem&gt;&lt;FormItem label=&quot;区/县: &quot;&gt; &lt;Select v-model=&quot;searchData.districtId&quot; placeholder=&quot;全部&quot; :disabled=&quot;isDisableAreaFlag&quot; size=&quot;small&quot;&gt; &lt;Option value=&quot;&quot;&gt;全部&lt;/Option&gt; &lt;Option v-for=&quot;item in areaSelectData&quot; :key=&quot;item.districtId&quot; :value=&quot;item.districtId&quot;&gt; &#123;&#123;item.districtName&#125;&#125; &lt;/Option&gt; &lt;/Select&gt;&lt;/FormItem&gt; script： 1234567891011121314151617import &#123; WindowSize, BreadCrumb, Region &#125; from '@/views/mixins';mixins: [Region],data() &#123; return &#123; searchData: &#123; provinceId: '', cityId: '', districtId: '' &#125; &#125;&#125;created() &#123; this.loadProvinceSelectData();&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[改变iVIew默认样式的方法]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%94%B9%E5%8F%98iVIew%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[改变iVIew默认样式的方法 自定义指令v-scoped改变的样式只在单个文件中生效，不污染全局样式。 封装@/directives/v-scoped.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var install = &#123; install(Vue) &#123; var directiveFun = &#123; eachChild(el, scoped) &#123; if (!(el instanceof HTMLElement)) return; scoped.forEach(name =&gt; &#123; el.setAttribute(name, ''); &#125;); if (el.childNodes.length) &#123; for (var i = 0; i &lt; el.childNodes.length; i++) &#123; directiveFun.eachChild(el.childNodes[i], scoped); &#125; &#125; &#125;, getParentScoped(dom, layer) &#123; function getScoped(dom) &#123; var scoped = []; for (var i = 0; i &lt; dom.attributes.length; i++) &#123; var nodedate = dom.attributes[i]; if (nodedate &amp;&amp; String(nodedate.nodeName).substr(0, 7) === 'data-v-') &#123; scoped.push(nodedate.nodeName); &#125; &#125; return scoped; &#125; if (!dom) return; var domLayer = isNaN(layer) ? 0 : parseInt(layer); var scoped = []; var parent = dom; do &#123; var scopedList = getScoped(parent); scoped = scoped.concat(scopedList); parent = parent.parentNode; domLayer--; &#125; while (parent &amp;&amp; domLayer &gt; 0); return scoped; &#125; &#125;; // 全局注册 自定义指令 Vue.directive('scoped', &#123; inserted: function(el) &#123; var scoped = directiveFun.getParentScoped(el, 2); if (scoped.length) &#123; directiveFun.eachChild(el, scoped); //批量追加 &#125; &#125; &#125;); &#125;&#125;;export default install; @/directives/index.js: 1234import vScoped from './v-scope';import Vue from 'vue';Vue.use(vScoped); 注册自定义指令： @/idnex.js: 12// 导入自定义指令 index.js 会使用Vue.use()来注册指令import '@/directives'; 用法 F12找到含有data-v的dom，手动添加class 在含有scoped的style里写上样式 123&lt;Select class="nameOne" v-scoped&gt; &lt;/Select&gt; 12345&lt;style scoped&gt; .nameOne .ivu-select-dropdown &#123; top: 34px; &#125;&lt;/style&gt; style不加scoped另一种方法是另写一个style，不加scoped，将要重写的iView写在其中。 但这样有一个缺点：定义的类名可能会污染全局样式。 因此必须保证手动添加的类名独一无二。 /deep/穿透直接通过检查元素找到className 123456789/deep/.vux-label::before &#123; content: '*'; display: inline-block; margin-right: 4px; line-height: 1; font-family: SimSun; font-size: 12px; color: #ed3f14;&#125; 注意：在less中，deep不能在嵌套写法中穿透2层，因此需要分开写2段 全局的iView样式可以全局更改iView样式。 @/style/public.less: 12345678@import url('../../../node_modules/iview/src/styles/index.less');.select30 .ivu-select-dropdown &#123; top: 30px !important;&#125;.search-bg .ivu-form-item&#123; margin-bottom: 5px !important;&#125; @/index.js: 1import '@/styles/public.less';]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记select下拉框的一个样式bug]]></title>
    <url>%2F2019%2F01%2F16%2F%E8%AE%B0select%E4%B8%8B%E6%8B%89%E6%A1%86%E7%9A%84%E4%B8%80%E4%B8%AA%E6%A0%B7%E5%BC%8Fbug%2F</url>
    <content type="text"><![CDATA[在页面高度过大存在滚动条时，使用iView的Select、DatePicker、Dropdown组件，下拉框会产生遮挡。 定位问题发现当select-dropdown超出页面时，会自动添加一个x-out-of-boundies属性，这时top会变成auto 解决办法改变iview默认样式，用v-scoped方法（或其他方法），top：30px ！important 1class="selectRowOne" v-scoped 123.selectRowOne .ivu-select-dropdown &#123; top: 34px !important;&#125; 效果： 改变iView默认样式参加改变iView默认样式的方法 优化 可以把这段css写在全局样式里。 同时解决了DatePicker、Dropdown的同样问题]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[按钮级权限控制]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%8C%89%E9%92%AE%E7%BA%A7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[按钮级权限控制。需后端配合给出接口，前端控制按钮的显隐性。 接口参数及返回格式接口参数：当前url 1url: "/jgpt/schoolCount/schoolManage" 后台接口格式： 包含按钮名称、唯一的code、是否展示的布尔值。 按钮权限的封装@/utils/btn-authority.js: 1234567891011121314151617181920212223242526272829303132333435363738import API from '@/plugins/api';// config &#123;按钮的集合&#125;const getAuthority = (config, item = []) =&gt; &#123; //深拷贝一次 不改变函数的形参 let myConfig = JSON.parse(JSON.stringify(config)); try &#123; item.forEach(t =&gt; &#123; Object.keys(myConfig).forEach(i =&gt; &#123; if (myConfig[i].actionCode === t.actionCode) &#123; myConfig[i].display = t.display; &#125; &#125;); &#125;); &#125; catch (error) &#123; throw new Error('权限配置失败，功能ID验证失败。'); &#125; finally &#123; // 无法在finally 使用 return语句 &#125; return myConfig;&#125;;/** * 配置按钮的权限服务器端URL地址 * 返回的结果是[&#123;id,display&#125;,] */export const fetchAuthority = config =&gt; &#123; let queryData = &#123; url: '' &#125;; queryData.url = window.currentRoute.path; return API['permission/btn'](queryData).then(data =&gt; &#123; let authority = getAuthority(config, data); return authority; &#125;);&#125;; 接口调用的封装参见axios封装及api调用方法 使用方法定义配置文件config.js: 12345678910111213141516171819202122232425262728293031323334353637383940export default &#123; authority: &#123; // 学校管理详情 schoolManage: &#123; func: &#123; edit: &#123; display: false, id: 12, name: '编辑', actionCode: 'schoolList_base_modify' &#125;, search: &#123; display: false, id: 81, name: '查询', actionCode: 'schoolList_search' &#125;, export: &#123; display: false, id: 83, name: '导出', actionCode: 'schoolList_export' &#125;, import: &#123; display: false, id: 82, name: '导入', actionCode: 'schoolList_import' &#125;, delete: &#123; display: false, id: 3100, name: '删除', actionCode: 'schoolList_delete' &#125; &#125;, pageName: '学校管理' &#125; &#125;&#125;; 页面index.vue: 123456789101112131415import &#123; fetchAuthority &#125; from '@/utils/btn-authority';import config from '../config.js';data() &#123; return &#123; authority: config.authority.schoolManage.func &#125; &#125;created() &#123; // 获取按钮的权限 fetchAuthority(this.authority).then(data =&gt; &#123; this.authority = data; &#125;);&#125; 模板： 12&lt;Button v-if=&quot;authority.export.display&quot;&gt;导出&lt;/Button&gt;&lt;Button v-if=&quot;authority.import.display&quot;&gt;导入&lt;/Button&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tree命令产生目录结构]]></title>
    <url>%2F2019%2F01%2F16%2Ftree%E5%91%BD%E4%BB%A4%E4%BA%A7%E7%94%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[tree产生生产目录结构 在写文档时，需要展示目录结构，可以使用windows下的tree命令。 cmd进入根文件夹，输入tree可以在控制台展示目录结构树。 更常用的方法是tree /f &gt; tree.txt，把产生的目录结构树写入到文件。]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用开发工具总结]]></title>
    <url>%2F2019%2F01%2F16%2F%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记录用到的开发工具 SwitchHosts 蓝湖 坚果云 Beyond Compare Typora MindMaster LICEcap]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iview中的datePicker总结]]></title>
    <url>%2F2019%2F01%2F15%2FiView%E4%B8%ADdatePicker%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[显示星期数 两个时间选择器的禁用联动 日期对象扩展 日期格式化 取昨天 判断两个时间是否超过一个月 获取周次 显示星期数开启属性 show-week-numbers 后，可以显示星期数。 12345678910111213141516171819&lt;DatePicker :open=&quot;open&quot; v-model=&quot;startTime&quot; show-week-numbers transfer confirm type=&quot;date&quot; @on-clear=&quot;handleClear&quot; @on-ok=&quot;handleOk&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;handleClick&quot;&gt; &lt;Icon type=&quot;ios-calendar-outline&quot;&gt;&lt;/Icon&gt; &lt;template v-if=&quot;!startTime || startTime === &apos;&apos;&quot;&gt;请选择开始日期&lt;/template&gt; &lt;template v-else&gt; &lt;span&gt; &#123;&#123;exportStartTime&#125;&#125;,&#123;&#123;exportStartTime | weekNum&#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/a&gt;&lt;/DatePicker&gt; 123456789101112watch:&#123; startTime: &#123; handler(value) &#123; if (value &amp;&amp; value instanceof Date) &#123; this.exportStartTime = value.format('yyyy-MM-dd'); &#125; else &#123; this.exportStartTime = ''; &#125; &#125;, immediate: true &#125;&#125; 12345678import &#123; getweek &#125; from '@/utils';filters: &#123; weekNum: function(value) &#123; if (!value) return ''; let weekNum = getweek(value); return `第$&#123;weekNum&#125;周`; &#125;&#125; 效果： getWeek方法见“日期对象扩展” 两个时间选择器的禁用联动产品任务daterange不太好用，因此改成2个时间选择器，需添加限制：开始时间不能晚于结束时间，结束时间不能早于开始时间。 12345678910&lt;Col span=&quot;4&quot;&gt; &lt;FormItem label=&quot;发送时间:&quot;&gt; &lt;DatePicker type=&quot;date&quot; placeholder=&quot;选择开始日期&quot; style =&quot;width:100%&quot; v-model=&quot;searchData.sendTimeStart&quot; :options=&quot;DateOptionsStart&quot;&gt;&lt;/DatePicker&gt; &lt;/FormItem&gt;&lt;/Col&gt;&lt;Col span=&quot;4&quot;&gt; &lt;FormItem label=&quot; ~ &quot;&gt; &lt;DatePicker type=&quot;date&quot; placeholder=&quot;选择结束日期&quot; style =&quot;width:100%&quot; v-model=&quot;searchData.sendTimeEnd&quot; size=&quot;small&quot; :options=&quot;DateOptionsEnd&quot;&gt;&lt;/DatePicker&gt; &lt;/FormItem&gt;&lt;/Col&gt; 1234567891011121314data() &#123; return &#123; DateOptionsStart: &#123; disabledDate(date) &#123; return ''; &#125; &#125;, DateOptionsEnd: &#123; disabledDate(date) &#123; return ''; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738watch: &#123; 'searchData.sendTimeEnd': &#123; handler: function(val) &#123; if (val) &#123; this.DateOptionsStart = &#123; disabledDate(date) &#123; return date.valueOf() &gt; new Date(val.format('yyyy-MM-dd')); &#125; &#125;; &#125; else &#123; this.DateOptionsStart = &#123; disabledDate(date) &#123; return ''; &#125; &#125;; &#125; &#125;, immediate: true &#125;, 'searchData.sendTimeStart': &#123; handler: function(val) &#123; if (val) &#123; this.DateOptionsEnd = &#123; disabledDate(date) &#123; return date.valueOf() &lt; new Date(val.format('yyyy-MM-dd')) - 86400000; &#125; &#125;; &#125; else &#123; this.DateOptionsEnd = &#123; disabledDate(date) &#123; return ''; &#125; &#125;; &#125; &#125;, immediate: true &#125; &#125; Date.format见“日期对象扩展” 日期对象扩展日期格式化datePicker取到的时间和从后端拿到的时间，最好进行format格式化，否则在前后端的数据传递中，可能会导致日期少一天 @/utils/index.js: 1234567891011121314151617181920Date.prototype.format = function(format) &#123; let o = &#123; 'M+': this.getMonth() + 1, //month 'd+': this.getDate(), //day 'h+': this.getHours(), //hour 'm+': this.getMinutes(), //minute 's+': this.getSeconds(), //second 'q+': Math.floor((this.getMonth() + 3) / 3), //quarter S: this.getMilliseconds() //millisecond &#125;; if (/(y+)/.test(format)) &#123; format = format.replace(RegExp.$1, (this.getFullYear() + '').substr(4 - RegExp.$1.length)); &#125; for (let k in o) &#123; if (new RegExp('(' + k + ')').test(format)) &#123; format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ('00' + o[k]).substr(('' + o[k]).length)); &#125; &#125; return format;&#125;; @/index.js: 1import '@/utils'; 取昨天123export function yesterday() &#123; return new Date(new Date().getTime() - 1000 * 60 * 60 * 24 * 1);&#125; 判断两个时间是否超过一个月1234567891011121314151617181920212223export function isBeyondMonth(startTime, endTime) &#123; let sDate = new Date(startTime); let eDate = new Date(endTime); if (eDate.getFullYear() - sDate.getFullYear() &gt; 1) &#123; //先比较年 return true; &#125; else if (eDate.getMonth() - sDate.getMonth() &gt; 1) &#123; //再比较月 return true; &#125; else if (eDate.getMonth() - sDate.getMonth() == 1) &#123; if (eDate.getDate() - sDate.getDate() &gt;= 1) &#123; return true; &#125; &#125; else if (eDate.getFullYear() - sDate.getFullYear() == 1) &#123; if (eDate.getMonth() + 12 - sDate.getMonth() &gt; 1) &#123; return true; &#125; else if (eDate.getDate() - sDate.getDate() &gt;= 1) &#123; return true; &#125; &#125; return false;&#125; 获取周次1234567891011121314151617181920212223242526272829303132333435363738export function getweek(z) &#123; //参数z是"2018-05-07 15:12:36"或者"2018/05/07 15:12:36" let day = Date.parse(z); let day11 = new Date(day); day11.setMonth(0); day11.setDate(1); day11.setHours(0); day11.setMinutes(0); day11.setSeconds(0); //到这里就得到该年的一月一日 let day11mill = day11.getTime(); let ori_day = day11.getDay(); //该年的一月一日是星期几 let fill1 = 0; //与星期日相隔的毫秒数 if (ori_day !== 0) &#123; fill1 = ori_day * 60 * 60 * 24 * 1000; &#125; let now = Date.parse(z); now = new Date(now); now.setHours(0); now.setMinutes(0); now.setSeconds(0); let nowmill = now.getTime(); let now_day = now.getDay(); let fill2 = 0; if (now_day !== 0) &#123; fill2 = (7 - now_day) * 60 * 60 * 24 * 1000; &#125; let cha2 = (nowmill - day11mill + fill1 + fill2) / (60 * 60 * 24 * 1000); let week = Math.ceil(cha2 / 7); if (week &lt; 10) &#123; week = '0' + week; &#125; let year = now.getFullYear().toString(); year = year.substring(2); return week;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[echarts在Vue中的封装]]></title>
    <url>%2F2019%2F01%2F15%2Fecharts%E5%9C%A8Vue%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[封装echarts 封装echarts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224&lt;template&gt; &lt;div class=&quot;echarts&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import echarts from &apos;echarts&apos;;import _debounce from &apos;lodash/debounce&apos;;// enumerating ECharts events for nowconst ACTION_EVENTS = [ &apos;legendselectchanged&apos;, &apos;legendselected&apos;, &apos;legendunselected&apos;, &apos;datazoom&apos;, &apos;datarangeselected&apos;, &apos;timelinechanged&apos;, &apos;timelineplaychanged&apos;, &apos;restore&apos;, &apos;dataviewchanged&apos;, &apos;magictypechanged&apos;, &apos;geoselectchanged&apos;, &apos;geoselected&apos;, &apos;geounselected&apos;, &apos;pieselectchanged&apos;, &apos;pieselected&apos;, &apos;pieunselected&apos;, &apos;mapselectchanged&apos;, &apos;mapselected&apos;, &apos;mapunselected&apos;, &apos;axisareaselected&apos;, &apos;brush&apos;, &apos;brushselected&apos;];const MOUSE_EVENTS = [&apos;click&apos;, &apos;dblclick&apos;, &apos;mouseover&apos;, &apos;mouseout&apos;, &apos;mousedown&apos;, &apos;mouseup&apos;, &apos;globalout&apos;];export default &#123; name: &apos;myChart&apos;, data() &#123; return &#123; chart: null &#125;; &#125;, props: &#123; options: Object, theme: [String, Object], initOptions: Object, group: String, autoResize: Boolean &#125;, computed: &#123; // Only recalculated when accessed from JavaScript. // Won&apos;t update DOM on value change because getters // don&apos;t depend on reactive values width: &#123; cache: false, get() &#123; return this.chart.getWidth(); &#125; &#125;, height: &#123; cache: false, get() &#123; return this.chart.getHeight(); &#125; &#125;, isDisposed: &#123; cache: false, get() &#123; return this.chart.isDisposed(); &#125; &#125; &#125;, watch: &#123; // use assign statements to tigger &quot;options&quot; and &quot;group&quot; setters options: &#123; handler(options) &#123; if (!this.chart &amp;&amp; options) &#123; this._initEchart(); &#125; else &#123; this.chart.setOption(this.options, true); &#125; &#125;, deep: true &#125;, group: &#123; handler(group) &#123; this.chart.group = group; &#125; &#125; &#125;, methods: &#123; // provide a explicit merge option method mergeOptions(options) &#123; this._delegateMethod(&apos;setOption&apos;, options); &#125;, // just delegates ECharts methods to Vue component // use explicit params to reduce transpiled size for now resize(options) &#123; this._delegateMethod(&apos;resize&apos;, options); &#125;, dispatchAction(payload) &#123; this._delegateMethod(&apos;dispatchAction&apos;, payload); &#125;, convertToPixel(finder, value) &#123; return this._delegateMethod(&apos;convertToPixel&apos;, finder, value); &#125;, convertFromPixel(finder, value) &#123; return this._delegateMethod(&apos;convertFromPixel&apos;, finder, value); &#125;, containPixel(finder, value) &#123; return this._delegateMethod(&apos;containPixel&apos;, finder, value); &#125;, showLoading(type, options) &#123; this._delegateMethod(&apos;showLoading&apos;, type, options); &#125;, hideLoading() &#123; this._delegateMethod(&apos;hideLoading&apos;); &#125;, getDataURL(options) &#123; return this._delegateMethod(&apos;getDataURL&apos;, options); &#125;, getConnectedDataURL(options) &#123; return this._delegateMethod(&apos;getConnectedDataURL&apos;, options); &#125;, clear() &#123; this._delegateMethod(&apos;clear&apos;); &#125;, dispose() &#123; this._delegateMethod(&apos;dispose&apos;); &#125;, _delegateMethod(name, ...args) &#123; if (!this.chart) &#123; // Vue.util.warn(`Cannot call [$&#123;name&#125;] before the chart is initialized. Set prop [options] first.`, this); this.$Message.error(`Cannot call [$&#123;name&#125;] before the chart is initialized. Set prop [options] first.`); return; &#125; return this.chart[name](...args); &#125;, _initEchart() &#123; if (this.chart) &#123; return; &#125; let chart = echarts.init(this.$el, this.theme, this.initOptions); if (this.group) &#123; chart.group = this.group; &#125; chart.setOption(this.options, true); // expose ECharts events as custom events ACTION_EVENTS.forEach(event =&gt; &#123; chart.on(event, params =&gt; &#123; this.$emit(event, params); &#125;); &#125;); MOUSE_EVENTS.forEach(event =&gt; &#123; chart.on(event, params =&gt; &#123; this.$emit(event, params); // for backward compatibility, may remove in the future this.$emit(&apos;chart&apos; + event, params); &#125;); &#125;); if (this.autoResize) &#123; this.__resizeHanlder = _debounce( () =&gt; &#123; chart.resize(); &#125;, 100, &#123; leading: true &#125; ); window.addEventListener(&apos;resize&apos;, this.__resizeHanlder); &#125; this.chart = chart; &#125; &#125;, mounted() &#123; // auto init if `options` is already provided if (this.options) &#123; this.$nextTick(() =&gt; &#123; this._initEchart(); &#125;); &#125; &#125;, activated() &#123; if (this.autoResize) &#123; this.chart &amp;&amp; this.chart.resize(); &#125; &#125;, beforeDestroy() &#123; if (!this.chart) &#123; return; &#125; if (this.autoResize) &#123; window.removeEventListener(&apos;resize&apos;, this.__resizeHanlder); &#125; this.dispose(); &#125;, connect(group) &#123; if (typeof group !== &apos;string&apos;) &#123; group = group.map(chart =&gt; chart.chart); &#125; echarts.connect(group); &#125;, disconnect(group) &#123; echarts.disConnect(group); &#125;, registerMap(...args) &#123; echarts.registerMap(...args); &#125;, registerTheme(...args) &#123; echarts.registerTheme(...args); &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;.echarts &#123; width: 100%; height: 100%;&#125;&lt;/style&gt; 传参： options 配置项 autoResize 是否自动缩放 注：引入lodash的防抖 进一步封装——折线图封装line-chart.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;template&gt; &lt;div class=&quot;line-chart-cnt&quot;&gt; &lt;MyChart :options=&quot;option&quot; :autoResize=&quot;true&quot;&gt;&lt;/MyChart&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyChart from &apos;@/components/my-chart&apos;;export default &#123; name: &apos;lineChart&apos;, data() &#123; return &#123; option: &#123; title: &#123; left: &apos;center&apos;, text: &apos;&apos; &#125;, xAxis: &#123; axisLabel: &#123; interval: 0, rotate: 40 &#125;, type: &apos;category&apos;, data: [] &#125;, yAxis: &#123; type: &apos;value&apos;, axisLabel: &#123; show: true, interval: &apos;auto&apos;, formatter: &apos;&#123;value&#125;%&apos; &#125; &#125;, series: [ &#123; data: [], type: &apos;line&apos; &#125; ] &#125; &#125;; &#125;, props: &#123; title: String, chartData: Array, xAxisData: Array &#125;, components: &#123; MyChart &#125;, mounted() &#123; this.option.title.text = this.title; this.option.xAxis.data = this.xAxisData; this.option.series[0].data = this.chartData; &#125;, watch: &#123; xAxisData: &#123; handler: function(val) &#123; this.option.xAxis.data = val; &#125;, immediate: true &#125;, chartData: &#123; handler: function(val) &#123; this.option.series[0].data = val; &#125;, immediate: true &#125;, title: &#123; handler: function(val) &#123; this.option.title.text = val; &#125;, immediate: true &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.line-chart-cnt &#123; width: 100%; height: 400px; padding: 0 40px;&#125;&lt;/style&gt; 传参： title 图表的标题 chartData 数据 xAxisData x轴数据 使用1&lt;LineChart :title=&quot;chartTitle&quot; :chartData=&quot;chartData&quot; :xAxisData=&quot;xAxisData&quot;&gt;&lt;/LineChart&gt; 进一步封装——饼图封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;template&gt; &lt;div class=&quot;line-chart-cnt&quot;&gt; &lt;MyChart :options=&quot;option&quot; :autoResize=&quot;true&quot;&gt;&lt;/MyChart&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyChart from &apos;@/components/my-chart&apos;;export default &#123; name: &apos;lineChart&apos;, data() &#123; return &#123; option: &#123; title: &#123; left: &apos;center&apos;, text: &apos;&apos; &#125;, tooltip: &#123; trigger: &apos;item&apos;, formatter: &apos;&#123;b&#125;&lt;br/&gt;&#123;d&#125;%&apos; &#125;, legend: &#123; orient: &apos;vertical&apos;, left: &apos;left&apos;, data: [] &#125;, series: [ &#123; type: &apos;pie&apos;, radius: &apos;55%&apos;, center: [&apos;50%&apos;, &apos;60%&apos;], data: [], itemStyle: &#123; emphasis: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: &apos;rgba(0, 0, 0, 0.5)&apos; &#125; &#125;, label: &#123; normal: &#123; formatter: &apos;&#123;b&#125;\n&#123;d&#125;%&apos; &#125; &#125; &#125; ], color: [ &apos;#004DA1&apos;, &apos;#009EA7&apos;, &apos;#AACD03&apos;, &apos;#F9BE00&apos;, &apos;#EC6C00&apos;, &apos;#A40081&apos;, &apos;#0068B6&apos;, &apos;#00A73B&apos;, &apos;#FFD800&apos;, &apos;#F29600&apos;, &apos;#E5002D&apos;, &apos;#541B85&apos; ] &#125; &#125;; &#125;, props: &#123; title: String, chartData: Array &#125;, mounted() &#123; this.option.title.text = this.title; this.option.series[0].data = this.chartData; this.chartData.forEach(item =&gt; &#123; this.option.legend.data.push(item.name); &#125;); &#125;, watch: &#123; chartData: &#123; handler: function(val) &#123; this.option.series[0].data = val; val.forEach(item =&gt; &#123; this.option.legend.data.push(item.name); &#125;); &#125;, immediate: true &#125;, title: &#123; handler: function(val) &#123; this.option.title.text = val; &#125;, immediate: true &#125; &#125;, components: &#123; MyChart &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.line-chart-cnt &#123; width: 100%; height: 400px; padding: 0 40px;&#125;&lt;/style&gt; 传参： title 图表的标题 chartData 数据 使用1&lt;SimplePie :title=&quot;&apos;各项目人力投向占比&apos;&quot; :chartData=&quot;pieChartData&quot;&gt;&lt;/SimplePie&gt; 进一步封装——柱状图封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;template&gt; &lt;div class=&quot;line-chart-cnt&quot;&gt; &lt;MyChart :options=&quot;option&quot; :autoResize=&quot;true&quot;&gt;&lt;/MyChart&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyChart from &apos;@/components/my-chart&apos;;export default &#123; name: &apos;BarChart&apos;, data() &#123; return &#123; option: &#123; title: &#123; left: &apos;center&apos;, text: &apos;&apos; &#125;, tooltip: &#123; trigger: &apos;axis&apos;, axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: &apos;shadow&apos; // 默认为直线，可选为：&apos;line&apos; | &apos;shadow&apos; &#125; &#125;, xAxis: &#123; type: &apos;category&apos;, data: [] &#125;, yAxis: &#123; type: &apos;value&apos;, axisLabel: &#123; show: true, interval: &apos;auto&apos; &#125; &#125;, series: [ &#123; data: [], type: &apos;bar&apos;, label: &#123; normal: &#123; show: true, position: &apos;top&apos; &#125; &#125;, itemStyle: &#123; normal: &#123; color: &apos;rgb(0,77,161)&apos; &#125; &#125; &#125; ] &#125; &#125;; &#125;, props: &#123; title: String, // 标题 chartData: Array, // 图标数据 xAxisData: Array, // x轴标签 isPercent: Boolean // true:y轴显示百分比，false：y轴显示数值 &#125;, components: &#123; MyChart &#125;, mounted() &#123; this.option.title.text = this.title; this.option.xAxis.data = this.xAxisData; this.option.series[0].data = this.chartData; &#125;, watch: &#123; xAxisData: &#123; handler: function(val) &#123; this.option.xAxis.data = val; &#125;, immediate: true &#125;, chartData: &#123; handler: function(val) &#123; this.option.series[0].data = val; &#125;, immediate: true &#125;, title: &#123; handler: function(val) &#123; this.option.title.text = val; &#125;, immediate: true &#125;, isPercent: &#123; handler: function(val) &#123; if (val) &#123; this.option.yAxis.axisLabel.formatter = &apos;&#123;value&#125;%&apos;; &#125; &#125;, immediate: true &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.line-chart-cnt &#123; width: 100%; height: 400px; padding: 0 40px;&#125;&lt;/style&gt; 传参： title 图表的标题 chartData 数据 xAxisData x轴数据 isPercent true:y轴显示百分比，false：y轴显示数值 使用1&lt;BarChart :title=&quot;&apos;活跃度&apos;&quot; :chartData=&quot;activityChartData&quot; :xAxisData=&quot;activityXAxisData&quot; :isPercent=&quot;true&quot;&gt;&lt;/BarChart&gt; 带辅助横线的柱状图辅助线只需设置series[index].markLine即可 封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;template&gt; &lt;div class=&quot;line-chart-cnt&quot;&gt; &lt;MyChart :options=&quot;option&quot; :autoResize=&quot;true&quot;&gt;&lt;/MyChart&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyChart from &apos;@/components/my-chart&apos;;export default &#123; name: &apos;MarkLineBarChart&apos;, data() &#123; return &#123; option: &#123; title: &#123; left: &apos;center&apos;, text: &apos;&apos; &#125;, tooltip: &#123; trigger: &apos;axis&apos;, axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: &apos;shadow&apos; // 默认为直线，可选为：&apos;line&apos; | &apos;shadow&apos; &#125; &#125;, xAxis: &#123; type: &apos;category&apos;, data: [] &#125;, yAxis: &#123; type: &apos;value&apos;, axisLabel: &#123; show: true, interval: &apos;auto&apos; &#125; &#125;, series: [ &#123; data: [], type: &apos;bar&apos;, label: &#123; normal: &#123; show: true, position: &apos;top&apos; &#125; &#125;, markLine: &#123; data: [ &#123; name: &apos;目标值&apos;, yAxis: &apos;&apos; &#125; ] &#125;, itemStyle: &#123; normal: &#123; color: &apos;rgba(0,77,161)&apos; &#125; &#125; &#125; ] &#125; &#125;; &#125;, props: &#123; title: String, // 标题 chartData: Array, // 图标数据 xAxisData: Array, // x轴标签 isPercent: Boolean, // true:y轴显示百分比，false：y轴显示数值 percentAim: Number // 百分比的目标值 &#125;, components: &#123; MyChart &#125;, mounted() &#123; this.option.title.text = this.title; this.option.xAxis.data = this.xAxisData; this.option.series[0].data = this.chartData; &#125;, watch: &#123; xAxisData: &#123; handler: function(val) &#123; this.option.xAxis.data = val; &#125;, immediate: true &#125;, chartData: &#123; handler: function(val) &#123; this.option.series[0].data = val; &#125;, immediate: true &#125;, title: &#123; handler: function(val) &#123; this.option.title.text = val; &#125;, immediate: true &#125;, isPercent: &#123; handler: function(val) &#123; if (val) &#123; this.option.yAxis.axisLabel.formatter = &apos;&#123;value&#125;%&apos;; &#125; &#125;, immediate: true &#125;, percentAim: &#123; handler: function(val) &#123; this.option.series[0].markLine.data[0].yAxis = val; &#125;, immediate: true &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.line-chart-cnt &#123; width: 100%; height: 400px; padding: 0 40px;&#125;&lt;/style&gt; 传参： title: String 图表的标题 chartData: Array 数据 xAxisData: Array x轴数据 isPercent: Boolean true:y轴显示百分比，false：y轴显示数值 percentAim: Number 百分比的目标值 使用1&lt;MarkLineBarChart :title=&quot;&apos;打卡完成率&apos;&quot; :chartData=&quot;closeLoopChartData&quot; :xAxisData=&quot;closeLoopXAxisData&quot; :isPercent=&quot;true&quot; :percentAim=&quot;90&quot;&gt;&lt;/MarkLineBarChart&gt; 覆盖的柱状图覆盖只需设每个series[index].barGap: &#39;-100%&#39;即可 封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;template&gt; &lt;div class=&quot;line-chart-cnt&quot;&gt; &lt;MyChart :options=&quot;option&quot; :autoResize=&quot;true&quot;&gt;&lt;/MyChart&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyChart from &apos;@/components/my-chart&apos;;import &#123; toPercent &#125; from &apos;@/utils&apos;;export default &#123; name: &apos;CoverBarChart&apos;, data() &#123; return &#123; option: &#123; title: &#123; left: &apos;center&apos;, text: &apos;&apos; &#125;, tooltip: &#123; trigger: &apos;axis&apos;, axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: &apos;shadow&apos; // 默认为直线，可选为：&apos;line&apos; | &apos;shadow&apos; &#125; &#125;, legend: &#123; data: [&apos;目标&apos;, &apos;实际&apos;], left: &apos;right&apos; &#125;, xAxis: &#123; type: &apos;category&apos;, data: [] &#125;, yAxis: &#123; type: &apos;value&apos;, axisLabel: &#123; show: true, interval: &apos;auto&apos; &#125; &#125;, series: [ &#123; name: &apos;目标&apos;, data: [], type: &apos;bar&apos;, barGap: &apos;-100%&apos;, label: &#123; normal: &#123; show: true, position: &apos;top&apos;, offset: [55, 0] &#125; &#125;, itemStyle: &#123; normal: &#123; color: &apos;rgba(0,77,161)&apos; &#125; &#125; &#125;, &#123; name: &apos;实际&apos;, data: [], type: &apos;bar&apos;, barGap: &apos;-100%&apos;, label: &#123; normal: &#123; show: true, position: &apos;top&apos;, formatter: &apos;&apos; &#125; &#125;, itemStyle: &#123; normal: &#123; color: &apos;rgba(249,190,0,0.7)&apos; // opacity: 0.7 &#125; &#125; &#125; ] &#125; &#125;; &#125;, props: &#123; title: String, xAxisData: Array, AimChartData: Array, factChartData: Array &#125;, components: &#123; MyChart &#125;, mounted() &#123; this.option.title.text = this.title; this.option.xAxis.data = this.xAxisData; this.option.series[0].data = this.AimChartData; this.option.series[1].data = this.factChartData; &#125;, watch: &#123; xAxisData: &#123; handler: function(val) &#123; this.option.xAxis.data = val; &#125;, immediate: true &#125;, AimChartData: &#123; handler: function(val) &#123; this.option.series[0].data = val; &#125;, immediate: true &#125;, factChartData: &#123; handler: function(val) &#123; this.option.series[1].data = val; this.option.series[1].data.forEach((item, index) =&gt; &#123; this.option.series[1].label.normal.formatter = `$&#123;item&#125;，$&#123;toPercent( item / this.option.series[0].data[index] )&#125;`; &#125;); &#125;, immediate: true &#125;, title: &#123; handler: function(val) &#123; this.option.title.text = val; &#125;, immediate: true &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.line-chart-cnt &#123; width: 100%; height: 400px; padding: 0 40px;&#125;&lt;/style&gt; 传参： title: String 图表的标题 xAxisData: Array x轴数据 AimChartData: Array 两个数据 factChartData: Array 使用1&lt;CoverBarChart :title=&quot;&apos;粉丝老师达成情况&apos;&quot; :AimChartData=&quot;AimChartData&quot; :factChartData=&quot;factChartData&quot; :xAxisData=&quot;fanXAxisData&quot;&gt;&lt;/CoverBarChart&gt; 参考：https://qjzd.net/topic/59afb984b9fded0f2581c259]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[echarts设置颜色]]></title>
    <url>%2F2019%2F01%2F15%2Fecharts%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[标准色 配色 项目中，产品给的图表往往颜色难看，需UI协助给出图表的颜色。 其实只需按照色环进行配色即可。 标准色介绍12阶色环如下所示： 6阶标准色： 12阶标准色 用法 饼状图色块在1-6个时，使用“6阶标准色”，超过6个使用“12阶标准色” 柱状图单一色时使用标准色1，之后按顺序使用标准色 echarts 配色## 饼图饼图设置option.color数组 1234567891011121314color: [ '#004DA1', '#009EA7', '#AACD03', '#F9BE00', '#EC6C00', '#A40081', '#0068B6', '#00A73B', '#FFD800', '#F29600', '#E5002D', '#541B85'] 柱状图柱状图设置option.series[index].itemStyle 123itemStyle: &#123; normal: &#123; color: 'rgb(0,77,161)' &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iView表格列筛选的组件封装]]></title>
    <url>%2F2019%2F01%2F15%2FiView%E8%A1%A8%E6%A0%BC%E5%88%97%E7%AD%9B%E9%80%89%E7%9A%84%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[当表格列过多时，可设置筛选选择要展示的列 tableColumnFilter.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;div&gt; &lt;Button type=&quot;primary&quot; @click=&quot;showFilterPanelFlag = !showFilterPanelFlag&quot;&gt; &lt;span class=&quot;icon_filter&quot;&gt;&lt;/span&gt; &lt;/Button&gt; &lt;transition&gt; &lt;div v-show=&quot;showFilterPanelFlag&quot; class=&quot;filter-panel&quot;&gt; &lt;CheckboxGroup v-model=&quot;selected&quot; @on-change=&quot;checkAllGroupChange&quot;&gt; &lt;div v-for=&quot;item in filterFiled&quot; :key=&quot;item&quot;&gt; &lt;Checkbox :label=&quot;item&quot; style=&quot;margin: 2px 5px&quot;&gt;&lt;/Checkbox&gt; &lt;/div&gt; &lt;/CheckboxGroup&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;tableColumnFilter&quot;, props: &#123; filterFiled: &#123; type: Array, default: function () &#123; return [&apos;标题&apos;, &apos;年度&apos;, &apos;版本&apos;, &apos;创建人&apos;, &apos;创建时间&apos;, &apos;使用状态&apos;] &#125; &#125;, defaultCheck: &#123; type: Array &#125; &#125;, data() &#123; return &#123; showFilterPanelFlag: false, //已选中的数据 selected: [...this.defaultCheck], &#125; &#125;, methods: &#123; checkAllGroupChange() &#123; this.$emit(&apos;filter-field-change&apos;, this.selected); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt; .filter-panel &#123; width: 166px; min-height: 120px; height: 500px; position: absolute; background-color: white; z-index: 9999; margin-left: -113px; overflow-y: scroll; &#125; .icon_filter &#123; display: inline-block; width: 14px; height: 14px; position: relative; top: 5px; background: url(&quot;filter.png&quot;) no-repeat center center; &#125;&lt;/style&gt; example.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371&lt;template&gt; &lt;div&gt; &lt;Row type=&quot;flex&quot; justify=&quot;space-between&quot; align=&quot;middle&quot;&gt; &lt;Col&gt; &lt;div class=&quot;alertTips&quot;&gt; &lt;Alert&gt; 可筛选要展示的列 &lt;/Alert&gt; &lt;/div&gt; &lt;/Col&gt; &lt;Col&gt; &lt;tableColumnFilter :filterFiled=&quot;[ &apos;学期&apos;, &apos;年级&apos;, &apos;学院&apos;, &apos;专业&apos;, &apos;课程名称&apos;, &apos;课程代码&apos;, &apos;教学班名称&apos;, &apos;实际班级人数&apos;, &apos;是否录入成绩&apos;, &apos;是否排课&apos;, &apos;是否选课&apos;, &apos;成绩录入人&apos;, &apos;连排节数&apos;, &apos;周学时&apos;, &apos;学时&apos;, &apos;学分&apos;, &apos;成绩分制&apos;, &apos;老师端展示形式&apos;, &apos;学生端展现形式&apos;, &apos;学生选课比例&apos;, &apos;是否需要校验地点冲突&apos;, &apos;是否需要校验教师冲突&apos;, &apos;是否需要校验学生冲突&apos;, &apos;答疑学时&apos;, &apos;授课教师&apos;, &apos;上课周次&apos;, ]&quot; :defaultCheck=&quot;[ &apos;学期&apos;, &apos;年级&apos;, &apos;学院&apos;, &apos;专业&apos;, &apos;课程名称&apos;, &apos;课程代码&apos;, &apos;教学班名称&apos;, &apos;实际班级人数&apos; ]&quot; @filter-field-change=&quot;refreshTable&quot;&gt; &lt;/tableColumnFilter&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;div&gt; &lt;Table :data=&quot;tableData&quot; :columns=&quot;tableColumns&quot; border&gt;&lt;/Table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import tableColumnFilter from &apos;./tableColumnFilter&apos; export default &#123; name: &apos;taskManager&apos;, data() &#123; let index = &#123; title: &apos; &apos;, type: &apos;index&apos;, width: 60, align: &apos;center&apos; &#125;; let term = &#123; title: &apos;学期&apos;, key: &apos;term&apos;, align: &apos;center&apos;, customOrder: 2 &#125;; let grade = &#123; title: &apos;年级&apos;, key: &apos;grade&apos;, align: &apos;center&apos;, customOrder: 3 &#125;; let departmentName = &#123; title: &apos;学院&apos;, key: &apos;departmentName&apos;, align: &apos;center&apos;, customOrder: 4 &#125;; let major = &#123; title: &apos;专业&apos;, key: &apos;major&apos;, align: &apos;center&apos;, customOrder: 5 &#125;; let courseName = &#123; title: &apos;课程名称&apos;, key: &apos;courseName&apos;, align: &apos;center&apos;, customOrder: 6 &#125;; let courseCode = &#123; title: &apos;课程代码&apos;, key: &apos;courseCode&apos;, align: &apos;center&apos;, customOrder: 7 &#125;; let className = &#123; title: &apos;教学班名称&apos;, key: &apos;className&apos;, align: &apos;center&apos;, customOrder: 8 &#125;; let classCount = &#123; title: &apos;实际班级人数&apos;, key: &apos;classCount&apos;, align: &apos;center&apos;, customOrder: 9, render: (h, params) =&gt; &#123; return h(&apos;a&apos;, &#123;&#125;, params.row.classCount) &#125; &#125;; const hasScore = &#123; title: &apos;是否录入成绩&apos;, key: &apos;hasScore&apos;, align: &apos;center&apos;, customOrder: 10 &#125;; let hasSchedule = &#123; title: &apos;是否排课&apos;, key: &apos;hasSchedule&apos;, align: &apos;center&apos;, customOrder: 11 &#125;; let hasChoose = &#123; title: &apos;是否选课&apos;, key: &apos;hasChoose&apos;, align: &apos;center&apos;, customOrder: 12 &#125;; let scorePerson = &#123; title: &apos;成绩录入人&apos;, key: &apos;scorePerson&apos;, align: &apos;center&apos;, customOrder: 13 &#125;; let sequentNum = &#123; title: &apos;连排节数&apos;, key: &apos;sequentNum&apos;, align: &apos;center&apos;, customOrder: 14 &#125;; let weekTime = &#123; title: &apos;周学时&apos;, key: &apos;weekTime&apos;, align: &apos;center&apos;, customOrder: 15 &#125;; let time = &#123; title: &apos;学时&apos;, key: &apos;time&apos;, align: &apos;center&apos;, customOrder: 16 &#125;; let credit = &#123; title: &apos;学分&apos;, key: &apos;credit&apos;, align: &apos;center&apos;, customOrder: 17 &#125;; let scoreFormat = &#123; title: &apos;成绩分制&apos;, key: &apos;scoreFormat&apos;, align: &apos;center&apos;, customOrder: 18 &#125;; let displayTeacher = &#123; title: &apos;老师端展示形式&apos;, key: &apos;displayTeacher&apos;, align: &apos;center&apos;, customOrder: 19 &#125;; let displayStudent = &#123; title: &apos;学生端展现形式&apos;, key: &apos;displayStudent&apos;, align: &apos;center&apos;, customOrder: 20 &#125;; let percent = &#123; title: &apos;学生选课比例&apos;, key: &apos;percent&apos;, align: &apos;center&apos;, customOrder: 21 &#125;; let conflictPlace = &#123; title: &apos;是否需要校验地点冲突&apos;, key: &apos;conflictPlace&apos;, align: &apos;center&apos;, customOrder: 22 &#125;; let conflictTeacher = &#123; title: &apos;是否需要校验教师冲突&apos;, key: &apos;conflictTeacher&apos;, align: &apos;center&apos;, customOrder: 23 &#125;; let conflictStudent = &#123; title: &apos;是否需要校验学生冲突&apos;, key: &apos;conflictStudent&apos;, align: &apos;center&apos;, customOrder: 24 &#125;; let questionTime = &#123; title: &apos;答疑学时&apos;, key: &apos;questionTime&apos;, align: &apos;center&apos;, customOrder: 25 &#125;; let teacher = &#123; title: &apos;授课教师&apos;, key: &apos;teacher&apos;, align: &apos;center&apos;, customOrder: 26 &#125;; let week = &#123; title: &apos;上课周次&apos;, key: &apos;week&apos;, align: &apos;center&apos;, customOrder: 27 &#125;; let action = &#123; title: &apos;操作&apos;, key: &apos;action&apos;, width: 160, align: &apos;center&apos;, render: (h, params) =&gt; &#123; let readView = h(&apos;a&apos;, &#123; on: &#123; click: () =&gt; &#123; console.log(12); &#125; &#125; &#125;, &apos;管理学生名单&apos;); return h(&apos;div&apos;, &#123;&#125;, [readView]); &#125;, &#125;; return &#123; tableColumns: [ index, term, grade, departmentName, major, courseName, courseCode, className, classCount, action ], tableData: [ &#123; term: &apos;第一学期&apos;, grade: &apos;2018级&apos;, departmentName: &apos;食品学院&apos;, major: &apos;食品加工技术&apos;, courseName: &apos;大学生心里健康&apos;, courseCode: &apos;98903782&apos;, className: &apos;2018级体育-食品营养与健康1班&apos;, classCount: &apos;100&apos;, hasScore: &apos;是&apos;, hasSchedule: &apos;是&apos;, hasChoose: &apos;是&apos;, scorePerson: &apos;zhang&apos;, sequentNum: &apos;2&apos;, weekTime: &apos;2&apos;, time: &apos;2&apos;, credit: &apos;2&apos;, scoreFormat: &apos;百分&apos;, displayTeacher: &apos;百分&apos;, displayStudent: &apos;百分&apos;, percent: &apos;100%&apos;, conflictPlace: &apos;是&apos;, conflictTeacher: &apos;是&apos;, conflictStudent: &apos;是&apos;, questionTime: &apos;2&apos;, teacher: &apos;2&apos;, week: &apos;2&apos;, &#125; ], //固定的两个列 index, action, //用于匹配 labelInfo: &#123; 学期: &apos;term&apos;, 年级: &apos;grade&apos;, 学院: &apos;departmentName&apos;, 专业: &apos;major&apos;, 课程名称: &apos;courseName&apos;, 课程代码: &apos;courseCode&apos;, 教学班名称: &apos;className&apos;, 实际班级人数: &apos;classCount&apos;, 是否录入成绩: &apos;hasScore&apos;, 是否排课: &apos;hasSchedule&apos;, 是否选课: &apos;hasChoose&apos;, 成绩录入人: &apos;scorePerson&apos;, 连排节数: &apos;sequentNum&apos;, 周学时: &apos;weekTime&apos;, 学时: &apos;time&apos;, 学分: &apos;credit&apos;, 成绩分制: &apos;scoreFormat&apos;, 老师端展示形式: &apos;displayTeacher&apos;, 学生端展现形式: &apos;displayStudent&apos;, 学生选课比例: &apos;percent&apos;, 是否需要校验地点冲突: &apos;conflictPlace&apos;, 是否需要校验教师冲突: &apos;conflictTeacher&apos;, 是否需要校验学生冲突: &apos;conflictStudent&apos;, 答疑学时: &apos;questionTime&apos;, 授课教师: &apos;teacher&apos;, 上课周次: &apos;week&apos;, &#125;, //所有列 tableFieldInfo: &#123; term: term, grade: grade, departmentName: departmentName, major: major, courseName: courseName, courseCode: courseCode, className: className, classCount: classCount, hasScore: hasScore, hasSchedule: hasSchedule, hasChoose: hasChoose, scorePerson: scorePerson, sequentNum: sequentNum, weekTime: weekTime, time: time, credit: credit, scoreFormat: scoreFormat, displayTeacher: displayTeacher, displayStudent: displayStudent, percent: percent, conflictPlace: conflictPlace, conflictTeacher: conflictTeacher, conflictStudent: conflictStudent, questionTime: questionTime, teacher: teacher, week: week, &#125; &#125; &#125;, methods: &#123; //过滤字段，刷新表格显示内容 refreshTable(selectedField) &#123; let showField = []; for (let item of selectedField) &#123; let fieldName = this.labelInfo[item]; showField.push(this.tableFieldInfo[fieldName]) &#125; if (showField.length) &#123; showField.sort((a, b) =&gt; &#123; return a.customOrder &gt; b.customOrder &#125;) &#125; //序号和操作固定 this.tableColumns = [this.index, ...showField, this.action]; &#125;, &#125;, components: &#123; tableColumnFilter, &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[eventbus封装]]></title>
    <url>%2F2018%2F12%2F25%2Feventbus%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[eventbus总结 封装src/plugins/eventbus.js: 12import Vue from 'vue';export default new Vue(); src/plugins/index.js: 12345678import eventbus from './eventbus';export default &#123; install: (Vue, options) =&gt; &#123; // 挂载实例 Vue.prototype.$bus = eventbus; &#125;&#125;; 使用.vue文件中使用手动触发1this.$bus.$emit('single-check', data); 其中，data为要传递的参数 监听在create生命周期中监听并调用回调函数。 12345678910created() &#123; this.$bus.$off(&apos;check-handler&apos;).$on(&apos;check-handler&apos;, row =&gt; &#123; this.$router.push(&#123; name: &apos;schoolContact&apos;, query: &#123; schoolId: row.schoolId &#125; &#125;); &#125;);&#125; js文件中使用手动触发需手动import 123import bus from '@/plugins/eventbus';bus.$emit('edit-handler', data);]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iView表格render函数总结]]></title>
    <url>%2F2018%2F12%2F25%2FiView%E8%A1%A8%E6%A0%BCrender%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[表格列单独放在JS文件里引入data 按钮的渲染以及eventbus通信 表头上渲染按钮 渲染绑定attrs 列的筛选 列的排序 表格列单独放在JS文件里引入data表格列的定义占据太多代码行数，可单独放在JS文件里引入data，并通过eventbus通信。 columnsData.js: 123456789export const columnsData = [ &#123; title: '省', key: 'provinceName', align: 'center', minWidth: 70, tooltip: true &#125;]; index.vue: 1234567import &#123; columnsData &#125; from &apos;./columnsData.js&apos;;data() &#123; return &#123; columnsData, &#125;&#125; 当列需要拼接时，可采用： 12345678data() &#123; return &#123; columnsData:[ ...columnsData1, ...columnsData2 ] &#125;&#125; 按钮的渲染以及eventbus通信columnsData.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344import bus from '@/plugins/eventbus';export const columnsData = [ &#123; title: '操作', align: 'center', width: 110, render: (h, params) =&gt; &#123; let edit = h( 'a', &#123; on: &#123; click: () =&gt; &#123; bus.$emit('edit-school-detail-handler', params.row); &#125; &#125; &#125;, '编辑' ); let deleteBtn = h( 'a', &#123; on: &#123; click: () =&gt; &#123;&#125; &#125;, style: &#123; marginLeft: '5px' &#125; &#125;, params.row.isDelete == '1' ? '已删除' : '删除' ); let sep = h( 'span', &#123; style: &#123; marginLeft: '5px' &#125; &#125;, '|' ); return h('div', &#123;&#125;, [edit, sep, deleteBtn]); &#125; &#125;]; index.vue: 123456789this.$bus.$off(&apos;edit-school-detail-handler&apos;).$on(&apos;edit-school-detail-handler&apos;, row =&gt; &#123; this.$router.push(&#123; name: &apos;schoolDetail&apos;, query: &#123; detailState: &apos;EDIT&apos;, schoolId: row.schoolId &#125; &#125;);&#125;); 效果： 表头上渲染按钮columnsData.js: 123456789101112131415161718192021222324252627282930export const columnsData = [ &#123; title: '编号', key: 'index', align: 'center', width: 50 &#125;, &#123; renderHeader: (h, params) =&gt; &#123; let add = h( 'a', &#123; class: &#123; operateBtn: true &#125;, on: &#123; click: () =&gt; &#123; bus.$emit('add-agent-handler'); &#125; &#125; &#125;, '添加' ); return h('div', &#123;&#125;, [add]); &#125;, key: 'action', align: 'center', minWidth: 120 &#125;]; 效果： 渲染绑定attrs若要在表格里动态渲染一个a标签，带href属性，并实现下载文件，如 1&lt;a href="sssss" download=""&gt;下载&lt;/a&gt; 可如下： 12345678910111213141516171819202122&#123; title: '操作', key: 'statusEnum', align: 'center', width: 100, render: (h, params) =&gt; &#123; let download = h( 'a', &#123; attrs: &#123; href: params.row.filePath, download: '' &#125;, on: &#123; click: () =&gt; &#123;&#125; &#125; &#125;, '下载' ); return h('div', &#123;&#125;, [download]); &#125;&#125; 同理可绑定img 中src属性 。 列的筛选当表格含有非常多列时，可进行筛选展示选择的列。 参见iview表格列筛选的组件封装 列的排序给 columns 数据的项，设置 sortable: true，即可对该列数据进行排序。 12345&#123; title: 'Date', key: 'date', sortable: true&#125;, 注： eventbus封装参阅 eventbus封装 表格行样式改变例如需求：删除的行置灰 12345678&lt;Table ref=&quot;selection&quot; v-scoped border :columns=&quot;schooColumnsData&quot; :data=&quot;tableData&quot; no-data-text=&quot;&quot; :row-class-name=&quot;rowClassName&quot;&gt;&lt;/Table&gt; 12345678910methods: &#123; // 表格行置灰 rowClassName(row) &#123; if (row.isDelete == '1') &#123; return 'demo-table-error-row'; &#125; else &#123; return ''; &#125; &#125;&#125; 12345&lt;style&gt;.ivu-table .demo-table-error-row td &#123; background-color: #ccc;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mixins在表格分页数据展示中的应用]]></title>
    <url>%2F2018%2F12%2F25%2Fmixins%E5%9C%A8%E8%A1%A8%E6%A0%BC%E5%88%86%E9%A1%B5%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[当系统中存在很多带分页的表格数据展示时，可以使用混入（mixins）减少代码量。 在混入中设置表格的设置表格最小高度，并预先设置好分页。 mixins/windowResize.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const mixin = &#123; data() &#123; const page = &#123; index: 1, size: 20, total: 20, list: [20, 50, 100] &#125;; return &#123; page &#125;; &#125;, mounted() &#123; window.addEventListener('resize', this.onWindowResize); this.$nextTick(() =&gt; &#123; this.onWindowResize(); &#125;); &#125;, destroyed() &#123; window.removeEventListener('resize', this.onWindowResize); &#125;, methods: &#123; onWindowResize: function() &#123; //获取表格距离顶部的距离 let offsetTopValue = this.$el.querySelector('.tableInfoBox').getOffset().top; //获取窗口可视区域 let innerHeight = window.innerHeight; //计算最小高度 let minHeight = innerHeight - offsetTopValue - 20; minHeight = minHeight &lt; 200 ? 200 : minHeight; //设置表格最小高度 this.$el.querySelector('.tableInfoBox').style.minHeight = minHeight + 'px'; this.$el.querySelector('.tableInfoBox .ivu-table-tip span').style.minHeight = minHeight - 50 + 'px'; &#125;, go(index) &#123; this.page.index = index; this.loadData(index); &#125;, size(size) &#123; this.page.size = size; this.loadData(); &#125; &#125;&#125;;export default mixin; mixins/index.js: 123import WindowSize from './windowResize';export &#123; WindowSize&#125;; example.vue: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class=&apos;tableInfoBox&apos; :class=&quot;&#123;hasDataAndPage:!!tableData.length&#125;&quot;&gt; &lt;Table v-scoped border :columns=&quot;columnsData&quot; :data=&quot;tableData&quot; no-data-text=&quot;&quot;&gt; &lt;/Table&gt; &lt;div class=&quot;webPage&quot; style=&quot;border: 0;&quot;&gt; &lt;Page v-if=&quot;tableData &amp;&amp; tableData.length !== 0&quot; class=&quot;Pager&quot; placement=&quot;top&quot; :total=&quot;page.total&quot; :page-size=&quot;page.size&quot; :current=&quot;page.index&quot; :page-size-opts=&quot;page.list&quot; show-sizer show-elevator show-total @on-change=&quot;go&quot; @on-page-size-change=&quot;size&quot;&gt; &lt;/Page&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; WindowSize&#125; from &apos;@/views/mixins&apos;; mixins: [WindowSize], data() &#123; return &#123; // data中不必再定义page columnsData: [], tableData: [] &#125; &#125;， created()&#123; this.loadData(); // 获取table数据方法必须为loadData &#125;， methods:&#123; loadData(pageIndex = 1) &#123; if (pageIndex) this.page.index = pageIndex; //重置表格的页码 let queryData = &#123; page: this.page.index, //传递分页参数 pageSize: this.page.size &#125;; Object.assign(queryData, this.searchData); this.$api[&apos;accurateTeaching/tableData&apos;](queryData).then(data =&gt; &#123; this.page.total = data.totalCount; this.tableData = data.dataList; &#125;); &#125;, &#125;&lt;/script&gt; @/utils/index.js: 12345678910111213141516171819HTMLElement.prototype.getOffset = function(stopSelectorElement) &#123; let offsetParent = this.offsetParent; let top = this.offsetTop, left = this.offsetLeft; while (offsetParent) &#123; top += offsetParent.offsetTop; left += offsetParent.offsetLeft; offsetParent = offsetParent.offsetParent; if (stopSelectorElement &amp;&amp; offsetParent === stopSelectorElement) &#123; break; &#125; &#125; return &#123; top: top, left: left, width: this.offsetWidth, height: this.offsetHeight &#125;;&#125;; @/index.js: 1import '@/utils'; 注意点： 类名为tableInfoBox、hasDataAndPage、webPage。详见iView常见全局样式 获取table数据方法必须为loadData 上例中异步获取数据详见Vue封装axios]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Beyond Compare提示”密钥被撤销“解决办法]]></title>
    <url>%2F2018%2F12%2F25%2FBeyond-Compare%E6%8F%90%E7%A4%BA%E6%8A%A5%E9%94%99%E5%AF%86%E9%92%A5%E8%A2%AB%E6%92%A4%E9%94%80%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[打开文件夹 1C:\Users\用户名\AppData\Roaming\Scooter Software\Beyond Compare 3 删除所有文件，重新启动软件]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小程序系列一——小程序部署手册]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[申请账号点击https://mp.weixin.qq.com/wxopen/waregister?action=step1 申请账号 注册成功后，可登陆微信公众平台https://mp.weixin.qq.com](https://mp.weixin.qq.com)在菜单 设置-开发设置 看到小程序的 AppID 了 。 创建项目新建项目时，选择空白文件夹，可创建quickStart示例项目。 目录结构其目录结构如下所示： 1234567891011121314151617181920project│ app.js ----------------------------程序入口│ app.json --------------------------全局配置│ app.wxss --------------------------全局样式│ project.config.json ----------------项目配置│ ├─pages --------------------------------页面文件夹│ ├─index│ │ index.js --------------------js│ │ index.wxml ------------------html│ │ index.wxss ------------------css│ │ │ └─logs│ logs.js│ logs.json ------------------页面配置│ logs.wxml│ logs.wxss│ └─utils --------------------------------工具类 util.js json配置配置页面路径、窗口表现、设置多 tab 等。 单个页面的json配置只有window一项。 app.js程序入口。 App() 必须在app.js中调用，必须调用且只能调用一次。接受一个 Object 参数，其指定小程序的生命周期回调等。 还可以在app.js中定义全局变量。 示例代码中在初始化小程序时，做了如下几件事。 1、调用 wx.login() 获取临时登录凭证code，可回传到开发者服务器。 2、使用 wx.getSetting() 获取用户当前的授权状态。 3、调用接口 wx.getUserInfo() ，获取用户信息。 发布准备团队身份管理可在微信公众平台统一管理项目成员、设置项目成员的权限。 入口：用户身份 – 成员管理 权限说明： 权限 说明 开发者权限 可使用小程序开发者工具进行开发 体验者权限 可使用体验版小程序 登录 可登录小程序管理后台，无需管理员确认 数据分析 使用小程序数据分析功能查看小程序数据 开发管理 小程序提交审核、发布、回退 开发设置 设置小程序服务器域名、消息推送 暂停服务设置 暂停小程序线上服务 服务器配置每个小程序需要事先设置通讯域名，小程序可以跟指定的域名与进行网络通信。包括普通 HTTPS 请求（request）、上传文件（uploadFile）、下载文件（downloadFile) 和 WebSocket 通信（connectSocket）。 在微信公众平台 - 设置 - 开发设置 - 服务器域名中，可配置服务器域名。 必须使用https请求 域名不能使用 IP 地址或 localhost 域名必须经过 ICP 备案 不校验合法域名若是请求不合法域名，会在控制台报错xxx不在以下 request 合法域名列表中，并无法请求。 在开发阶段，可以手动开启不校验合法域名。 开发者工具菜单设置 - 项目设置中勾选不校验合法域名。发出请求可以收到返回数据，控制台报一条警告。 预览使用开发者工具可以预览小程序。 点击开发者工具顶部预览按钮，开发者工具会自动打包当前项目，并上传小程序代码至微信的服务器，成功之后会在界面上显示一个二维码。使用当前小程序开发者的微信扫码即可看到小程序在手机客户端上的真实表现。 上传代码同预览不同，上传代码是用于提交体验或者审核使用的。 点击开发者工具顶部操作栏的上传按钮，填写版本号以及项目备注。上传成功之后，登录微信公众平台 - 开发管理 - 开发版本 就可以找到刚提交上传的版本了。 版本管理 版本 说明 开发版本 使用开发者工具，可将代码上传到开发版本中。开发版本只保留每人最新的一份上传代码。可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。 体验版本 供测试人员和产品经理测试的版本。可将开发版本选为体验版本。 审核中版本 只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。 线上版本 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。 上线填写基本信息小程序须先完成小程序基本资料填写后，方可提交审核。入口：微信公众平台 - 设置 - 基本设置 提交审核微信公众平台 - 开发管理 - 开发版本中提交审核，填写相关信息。 提交完毕后，可在审核版本中看到相关信息。 发布审核通过之后，管理员的微信中会收到审核通过的通知，此时登录 微信公众平台 - 开发管理 - 审核版本中可以看到通过审核的版本。 请点击发布，即可发布小程序。 发布完成后，可在 微信公众平台 - 设置 - 基本设置中下载自己小程序的二维码。（搜小程序名字暂时搜不到） 运营数据有两种方式可以方便的看到小程序的运营数据。 方法一： 登录 微信公众平台 - 数据分析 点击相应的 tab 可以看到相关的数据。 方法二： 使用小程序数据助手，在微信中方便的查看运营数据。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VsCode插件和配置]]></title>
    <url>%2F2018%2F11%2F12%2FVsCode%E6%8F%92%E4%BB%B6%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[插件通用Chinese (Simplified) Language Pack for Visual Studio Code适用于 VS Code 的中文（简体）语言包 安装后，在 locale.json 中添加 &quot;locale&quot;: &quot;zh-cn&quot;，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 Ctrl+Shift+P 打开命令面板，之后输入config` 筛选 JetBrains IDE KeymapwebStorm的快捷键 Path Intellisense文件路径提示 JSbeautify美化JS, JSON, CSS, Sass, 和HTML代码 按F1键选择Beautify file VueVeturVue代码高亮、格式化、自动补全、eslint检查 微信小程序minapp小程序标签、属性自动补全 vscode weapp api小程序 API 提示及代码片段 配置自动保存勾选文件-自动保存 代码片段Vue模板文件-首选项-用户代码片段-vue.json： 123456789101112131415161718192021222324&#123; "Print to console": &#123; "prefix": "vue", "body": [ "&lt;template&gt;", " &lt;div&gt;\n", " &lt;/div&gt;", "&lt;/template&gt;\n", "&lt;script&gt;", " export default &#123;", " data () &#123;", " return &#123;\n", " &#125;", " &#125;,", " &#125;", "&lt;/script&gt;\n", "&lt;style&gt;\n", " ", "&lt;/style&gt;", "$2" ], "description": "output Vue template" &#125;&#125;]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue最佳实践]]></title>
    <url>%2F2018%2F10%2F16%2FVue%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[化繁为简的Watch场景还原：12345678created()&#123; this.getData()&#125;,watch: &#123; inputValue()&#123; this.getData() &#125;&#125; 组件创建的时候我们获取一次列表数据，同时监听input框，每当发生变化的时候重新获取一次列表数据 优化：首先，在watchers中，可以直接使用函数的字面量名称；其次，声明immediate:true表示创建组件时立马执行一次。123456watch: &#123; searchInputValue:&#123; handler: &apos;fetchPostList&apos;, immediate: true &#125;&#125; DatePicker组件默认打开iView DatePicker组件，设置:open=&quot;true&quot;设置为默认打开。并用 1&lt;a href="javascript:void(0)"&gt;&lt;/a&gt; 隐藏默认的选择框。 .sync 修饰符.sync实际上是一个语法糖，用于实现父子组件间的数据双向绑定 用法：12345678//父组件&lt;child :childModalFlag.sync=&quot;showChildFlag&quot;&gt;&lt;/child&gt;data() &#123; return &#123; showWeekFlag: false &#125;&#125; 1234567891011121314151617//子组件&lt;Modal v-model=&quot;childModalFlag&quot;&gt;props:&#123; childModalFlag: &#123; required: true, type: Boolean &#125;&#125;methods:&#123; updateVisible(flag) &#123; this.childModalFlag = flag; this.$emit(&apos;update:childModalFlag&apos;, this.childModalFlag) // 更新对话框的显示状态 &#125;&#125; DatePicker组件判空element-ui DatePicker组件判空： value === &#39;&#39; || value === null Vuex 刷新失效Vuex在刷新以后，存储的数据会恢复原始状态。 因为Vuex是管理状态的工具，不是做持久存储的。 改用sessionStorage或localStorage DatePicker组件设置禁用范围12345678910111213&lt;el-date-picker :picker-options=&quot;pickerOptions&quot;&gt;&lt;/el-date-picker&gt;data()&#123; return &#123; pickerOptions: &#123; disabledDate(time) &#123; return time.getTime() &lt; Date.now() - 8.64e7; &#125; &#125; &#125;&#125; localhost改为IP地址package.json中改为： 123"scripts": &#123; "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js --host 10.4.0.217"&#125;, config/index.js中改为：host: &#39;10.4.0.217&#39;, 就可以在浏览器输入IP地址访问，局域网其他用户也可以访问 DatePicker 组件结束时间取值时应取endTime+1 通过ajax获取数据放到Select 选择器下拉选项中element-ui的Select组件 1234567data() &#123; return &#123; options: &#123; data: [] &#125; &#125;&#125; ajax回调里： 12345678let detail=[];data.list.forEach((i, v) =&gt; &#123; let obj = &#123;&#125;; obj.value = 'xx'; obj.label = 'xx'; detail.push(obj);&#125;);this.options.data = detail; template中： 1v-for=&quot;item in options.data&quot; Vue中使用echarts 需放在mounted中，因为需要取到DOM，不能放在created里。 不能用v-if，要用v-show，同理，DOM的问题。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件开发-测试-发布流程总结]]></title>
    <url>%2F2018%2F10%2F16%2FVue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91-%E6%B5%8B%E8%AF%95-%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[组件规范化开发要求 单文件组件开发（SFC） 单元测试实现 支持&lt;script&gt;及模块化规范引入 发布到npm 组件开发Vue组件开发规范 单元测试引入vue官方提供test-utils工具进行测试，并基于jest运行测试脚本。 编写单元测试脚本yourApp.spc.js： 打包构建虽然可以直接分享.vue文件，但这样会让那些想直接通过js引用的人无法使用，所以我们需要打包构建。 选择rollup打包，生成yourApp.umd.js到dist目录下，可直接引用。 发布到npm私服1234$ npm install nrm -g$ nrm add xxx http://xx.xx.xx.xx$ nrm use xxx$ npm publish]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用指南]]></title>
    <url>%2F2018%2F10%2F16%2Fhexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[什么是hexo基于Node.js的博客框架，使用Markdown解析文章 安装安装前提必须安装以下环境： Node.js Git 安装hexo$ npm install -g hexo-cli全局安装 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 目录结构12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml站点配置文件 scaffolds模板文件夹 page.md post.md draft.md source用户资源文件夹 _posts 文件夹存放md文件 themes主题文件夹 写作1`$ hexo new [layout] &lt;title&gt;` 自动生成名为test.md的markdown文件到_post文件夹下。 或者手动复制markdown文件至_post文件夹下，但需要手动添加头部信息： 123456---title: hexo使用指南date: 2018-10-16 10:39:26tags: 博客categories: 博客--- 更多展示在首页，多余部分隐藏： 1&lt;!--more--&gt; markdown语法的[TOC]目录，在hexo中无法展示 点击更多时，从头开始阅读： 1scroll_to_more: false 发布本地部署生成静态页面： 1`$ hexo generate` 或者简写： 1`$ hexo g` 启动服务器 1`$ hexo server` 或者简写： 1`$ hexo server` 提示： 1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 在浏览器中打开http://localhost:4000/ 部署到Github Page创建库新建一个名为yourname.github.io的库 在setting中开启github page 配置Deployment在_config.yml文件中，找到Deployment，然后按照如下修改，用户名改成自己的GitHub信息：需要注意的是：冒号后面记得空一格！ 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:xiamijun/xiamijun.github.io.git branch: master 提交12345678// 生成新的 public 文件hexo generate或者hexo g// 开始部署hexo deploye或者hexo d 排错 部署完毕后，githubPage打开显示404，项目setting中的githubPage项提示：The tag fancybox on line 77 in theme/landspace/README.md is not recognized Liquid tag 解决办法： 123rm -rf .deploy_githexo ghexo d 提示没有git仓库 解决办法： git init 其他报错 github issue 进阶解析到个人域名GitHub 仓库的根目录下建立一个 CNAME 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加http:// www.xxxxx.com 进入域名提供商地址，添加解析 注意：CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐 方法：通过安装插件实现永久保留 1$ npm install hexo-generator-cname --save 之后在_config.yml中添加一条 12plugins:- hexo-generator-cname Next主题hexo默认主题是landscape，可以更改为其他主题。 Next主题是目前较流行且成熟的主题。next主题文档 主题风格Next提供4个主题风格，选择自己想要的。 Muse Mist Pisces Gemini 更换头像代码高亮分类页新建分类页面 1hexo new page categories 给分类页面添加类型 在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。 12345---title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot; #这部分是新添加的--- 接下来的每篇文章中，都可以在头部添加分类信息： 12345---title: hexo使用指南date: 2018-10-16 10:39:26categories: 博客--- 标签页同样可以设置标签页 1hexo new page tags 给标签页面添加类型 在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。 123title: tagsdate: 2018-08-06 22:48:29type: &quot;tags&quot; #新添加的内容 接下来的每篇文章中，都可以在头部添加标签信息： 12345---title: hexo使用指南date: 2018-10-16 10:39:26tags: [博客,tag2]--- 修改底部建站信息修改主题的配置文件： 12345678910111213141516171819footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2018 # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). # version: true # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target=&quot;_blank&quot; href=&quot;https://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt; 隐藏hexo链接和Next链接 统计阅读次数使用LeanCloud的服务，具体方法参考教程,添加完之后效果如下： 注册LeanCloud帐号并验证邮箱之后，新建应用。 由于存在ACL权限问题，新建时选择无限制 左侧下划线开头的都是系统预定义好的表，新建一个表，名字必须为Counter 创建完成之后，左侧数据栏应该会多出一栏名为Counter的栏目 点击设置，选择应用Key，即可得到AppID以及AppKey 将其复制到主题配置文件： 1234leancloud_visitors: enable: true app_id: 111111-2222 app_key: 33333444 记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。 每次访问一篇文章后，Counter表就会多出一条字段，可以修改其中的time字段来修改阅读次数。 安全问题：在设置-安全中心-Web 安全域名中，填入自己的博客域名 字数统计与阅读时长打开/themes/next/layout/_macro/post.swig`文件 站内搜索安装插件 1npm install hexo-generator-searchdb --save 修改 主题配置文件 12local_search: enable: true 404页推荐用腾讯公益404页面，寻找丢失儿童，关注公益事业。 使用方法，新建404.html页面，放到主题的source目录下，内容如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 站点分析使用百度统计，注册百度统计，管理 &gt; 网站列表 &gt; 新增网站完成后，代码管理 &gt; 代码获取，就能得到统计id。 12# Baidu Analytics IDbaidu_analytics: 统计id 评论功能推荐使用[gitment](https://imsun.net/posts/gitment-introduction/) 注册 OAuth Application点击此处 来注册一个新的 OAuth Application 得到一个 client ID 和一个 client secret，将被用于之后的用户登录。 gitment配置配置项如下 123456789101112131415# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: true # Hide &apos;Powered by ...&apos; on footer, and more language: zh-CN # Force language, or auto switch by theme github_user: xxx # MUST HAVE, Your Github Username github_repo: xxx # MUST HAVE, The name of the repo you use to store Gitment comments client_id: xxx # MUST HAVE, Github client id for the Gitment client_secret: xxx # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled github授权后的用户就可以评论了 Valinegitment不太好用，换用Valine Valine是基于LeanCloud的评论系统，支持图片、emoji等 在LeanCloud上新建一个应用，取得其appId和appKey，修改主题配置文件： 1234valine: enable: true appid: xxxx appkey: xxxxx]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Vue双向绑定]]></title>
    <url>%2F2018%2F10%2F08%2F%E5%AE%9E%E7%8E%B0Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[Object.defineProperty()这个API是实现双向绑定的核心，最主要的作用是重写数据的get、set方法。 使用方法： 123456789101112131415161718192021222324252627282930let obj = &#123; singer: "周杰伦"&#125;;let default_value = "青花瓷";Object.defineProperty(obj, "music", &#123; // value: '七里香', // 设置属性的值，下面设置了get set函数，所以这里不能设置 configurable: false, // 是否可以删除属性，默认不能删除 // writable: true, // 是否可以修改对象，下面设置了get set函数，所以这里不能设置 enumerable: true, // music是否可以被枚举，默认是不能被枚举(遍历) //get,set设置时不能设置writable和value，要一对一对设置，交叉设置/同时存在就会报错 get() &#123; // 获取obj.music的时候就会调用get方法 // let default_value = "强行设置get的返回值"; // 打开注释 读取属性永远都是‘强行设置get的返回值’ return default_value; &#125;, set(val) &#123; // 将修改的值重新赋给song default_value = val; &#125;&#125;);console.log(obj.music); // 青花瓷delete obj.music; // configurable设为false 删除无效console.log(obj.music); // 青花瓷obj.music = "听妈妈的话"; console.log(obj.music); // 听妈妈的话for (let key in obj) &#123; // 默认情况下通过defineProperty定义的属性是不能被枚举(遍历)的 // 需要设置enumerable为true才可以 否则只能拿到singer 属性 console.log(key); // singer, music&#125; 实现思路 实现数据监听器Observer，用Object.defineProperty()重写数据的get、set，值更新就在set中通知订阅者更新数据。 实现模板编译Compile，深度遍历dom树，对每个元素节点的指令模板进行替换数据以及订阅数据。 实现Watch用于连接Observer和Compile，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。 流程图代码实现html结构1234567&lt;div id="wrap"&gt; &lt;p v-html="test"&gt;&lt;/p&gt; &lt;input type="text" v-model="form"&gt; &lt;input type="text" v-model="form"&gt; &lt;button @click="changeValue"&gt;改变值&lt;/button&gt; &#123;&#123;form&#125;&#125;&lt;/div&gt; JS调用12345678910111213141516new Vue(&#123; el: '#wrap', data: &#123; form: '这是form的值', test: '&lt;strong&gt;我是粗体&lt;/strong&gt;', obj: &#123; test: 123 &#125; &#125;, methods: &#123; changeValue() &#123; console.log(this.form); this.form = '改变了'; &#125; &#125; &#125;); Vue结构1234567891011class Vue&#123; constructor()&#123;&#125; proxyData()&#123;&#125; observer()&#123;&#125; compile()&#123;&#125; compileText()&#123;&#125;&#125;class Watcher&#123; constructor()&#123;&#125; update()&#123;&#125;&#125; Vue constructor 构造函数主要是数据的初始化 proxyData 数据代理 observer 劫持监听所有数据 compile 解析dom compileText 解析dom里处理纯双花括号的操作 Watcher 更新视图操作 Vue constructor 初始化1234567891011121314class Vue&#123;constructor(options = &#123;&#125;) &#123; this.$el = document.querySelector(options.el); let data = this.data = options.data; // 代理data，使其能直接this.xxx的方式访问data，正常的话需要this.data.xxx Object.keys(data).forEach(key =&gt; &#123; this.proxyData(key); &#125;); this.methods = options.methods; // 事件方法 this.watcherTask = &#123;&#125;; // 需要监听的任务列表 this.observer(data); // 初始化劫持监听所有数据 this.compile(this.$el); // 解析dom &#125;&#125; proxyData 代理data123456789101112131415161718class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key) &#123; let _this = this; Object.defineProperty(_this, key, &#123; configurable: false, enumerable: true, get() &#123; return _this.data[key]; &#125;, set(newVal) &#123; _this.data[key] = newVal; &#125; &#125;); &#125;&#125; 上面主要是代理data到最上层，this.xxx的方式直接访问data observer 劫持监听123456789101112131415161718192021222324252627282930class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key)&#123; ...... &#125; observer(data) &#123; let _this = this; Object.keys(data).forEach(key =&gt; &#123; let value = data[key]; _this.watcherTask[key] = []; Object.defineProperty(data, key, &#123; configurable: false, enumerable: true, get() &#123; return value; &#125;, set(newValue) &#123; if (newValue !== value) &#123; value = newValue; _this.watcherTask[key].forEach(task =&gt; &#123; task.update(); &#125;); &#125; &#125; &#125;) &#125;) &#125;&#125; 同样是使用Object.defineProperty来监听数据，初始化需要订阅的数据。 把需要订阅的数据到push到watcherTask里，等到时候需要更新的时候就可以批量更新数据了。 compile 解析dom123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key)&#123; ...... &#125; observer(data)&#123; ...... &#125; compile(el) &#123; let _this=this; let nodes = el.childNodes; for (let i = 0, len = nodes.length; i &lt; len; i++) &#123; const node = nodes[i]; if (node.nodeType === 3) &#123; let text = node.textContent.trim(); if (!text) &#123; continue; &#125; this.compileText(node, 'textContent'); &#125; else if (node.type === 1) &#123; if (node.childNodes.length &gt; 0) &#123; this.compile(node); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA')) &#123; node.addEventListener('input', (() =&gt; &#123; let attrVal = node.getAttribute('v-model'); this.watcherTask[attrVal].push(new Watcher(node, _this, attrVal, 'value')); // node.removeAttribute('v-model'); return () =&gt; &#123; this.data[attrVal] = node.value; &#125; &#125;)()); &#125; if (node.hasAttribute('v-html')) &#123; let attrVal = node.getAttribute('v-html'); this.watcherTask[attrVal].push(new Watcher(node, _this, attrVal, 'innerHTML')); // node.removeAttribute('v-html'); &#125; this.compileText(node, 'innerHTMl'); if (node.hasAttribute('@click')) &#123; let attrVal = node.getAttribute('@click'); // node.removeAttribute('@click'); node.addEventListener('click', e =&gt; &#123; this.methods[attrVal] &amp;&amp; this.methods[attrVal].bind(_this)() &#125;) &#125; &#125; &#125; &#125; compileText(node, type) &#123; let reg = /\&#123;\&#123;(.*?)\&#125;\&#125;/g; let txt = node.textContent; if (reg.test(txt)) &#123; node.textContent = txt.replace(reg, (matched, value) =&gt; &#123; let tpl = this.watcherTask[value] || []; tpl.push(new Watcher(node, this, value, type)); if (value.split('.').length&gt;1) &#123; let v=null; value.split('.').forEach((val,i)=&gt;&#123; v=!v?this[val]:v[val]; &#125;); return v; &#125;else &#123; return this[value]; &#125; &#125;) &#125; &#125;&#125; 首先我们先遍历el元素下面的所有子节点，node.nodeType === 3 的意思是当前元素是文本节点，node.nodeType === 1 的意思是当前元素是元素节点。因为可能有的是纯文本的形式，如纯双花括号就是纯文本的文本节点，然后通过判断元素节点是否还存在子节点，如果有的话就递归调用compile方法。 Watcher12345678910111213class Watcher &#123; constructor(el, vm, value, type) &#123; this.el = el; this.vm = vm; this.value = value; this.type = type; this.update(); &#125; update() &#123; this.el[this.type] = this.vm.data[this.value]; &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6编程风格]]></title>
    <url>%2F2018%2F09%2F30%2FES6%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[http://es6.ruanyifeng.com/#docs/style]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一台电脑绑定两个git账号]]></title>
    <url>%2F2018%2F09%2F29%2F%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E7%BB%91%E5%AE%9A%E4%B8%A4%E4%B8%AAgit%E8%B4%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[前言公司最近在推公共组件，要求每人分享自己组件到公司的git服务上。由于之前在公司电脑上绑定了自己的git，因此需要在一台电脑上绑定两个git账号。 生成部署新SHH key输入命令1ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 注意不要直接回车，第一步输入存储路径，可以找个其他路径先存放，再重命名后复制到.ssh目录下。 假设原有的自己的私钥和公钥分别命名为id_rsa和id_rsa.pub，新的公司的私钥和公钥分别命名为id_rsa_company和id_rsa_company.pub。 同样把新的公钥id_rsa_company.pub的内容复制到git服务的设置里。 添加秘钥到SSH Agent因为默认只读取id_rsa,为了让SSH识别新的私钥，需将其添加的SSH agent中。123ssh-agent bashssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_company 创建并配置config文件在.ssh目录下创建一个config文本文件,添加相关配置。1234567891011# default Host github.com HostName github.com User xiamijun IdentityFile ~/.ssh/id_rsa# two Host http://git.flyui.cn HostName http://git.flyui.cn User junxie4 IdentityFile ~/.ssh/id_rsa_company 测试ssh链接12ssh -T git@ieit.github.comssh -T git@github.com 如果成功，会显示欢迎信息，并显示用户名。 用户名/邮箱配置为了使提交代码不混淆，需要区分一下用户名和邮箱。 可以清楚全局设置，在每个仓库下单独设置用户名和邮箱，但这样较为繁琐。 由于平常自己的账号使用较多，公司的使用不多，所以使用自己的账号作为全局，公司的账号按需配置。 全局设置：12git config --global user.name &quot;xiamijun&quot;git config --global user.email &quot;171571466@qq.com&quot; 单个仓库设置：12git config user.name &quot;xxx&quot;git config user.email &quot;xxx@company.com&quot; 大功告成~]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eslint进行代码检查]]></title>
    <url>%2F2018%2F09%2F28%2Feslint%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[前言最近项目进行到收尾阶段，公司对于代码质量抓的比较严，后端一般使用sonar进行代码扫描。而JavaScript是弱类型语言，其实很有扫描检查的必要。sonar支持JS和typeScript的扫描，不支持Vue。因此改用eslint进行代码扫描。平常在开发中，都是嫌麻烦把eslint关掉的。。 安装依赖除了安装eslint以外，还需安装eslint-plugin-vue插件来检查Vue代码。直接-g吧。npm install eslint eslint-plugin-vue -g 配置一般推荐使用配置文件进行配置，在项目根目录下创建.eslintrc.json，其中写入各个配置项。如下：12345678910111213141516171819202122232425262728293031323334353637&#123; "root": true, //此项是用来告诉eslint找当前配置文件不能往父级查找 "extends": ["plugin:vue/essential","eslint:recommended"], //vue插件和推荐eslint规则 "parserOptions": &#123; "ecmaVersion": 6, "sourceType": "module", "ecmaFeatures": &#123; "jsx": true &#125; &#125;, //指定为浏览器环境 "env": &#123; "es6": true, "browser": true, "node": true &#125;, "rules": &#123; "camelcase": "error", "eqeqeq": "error", "no-console": "error", "no-alert": "error", "require-jsdoc": ["error", &#123; "require": &#123; "FunctionDeclaration": false, "MethodDefinition": false, "ClassDeclaration": false, "ArrowFunctionExpression": false &#125; &#125;], "new-cap": "error", "brace-style": "error", "comma-dangle": "error", "no-param-reassign": "error" &#125;&#125; 注意json中不能有注释，复制下来记得删除注释。 #规则举几个常用的规则：1234567891011&#123; &quot;no-alert&quot;: 2,//禁止使用alert confirm prompt &quot;no-console&quot;: 2,//禁止使用console &quot;no-const-assign&quot;: 2,//禁止修改const声明的变量 &quot;no-debugger&quot;: 2,//禁止使用debugger &quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &quot;no-dupe-args&quot;: 2,//函数参数不能重复 &quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复 &quot;no-empty&quot;: 2,//块语句中的内容不能为空 &quot;no-eval&quot;: 1,//禁止使用eval&#125; 具体规则见官网 https://eslint.org/docs/rules/ 代码扫描项目根目录运行eslint --ext .js,.vue src。或者将运行结果输出到文件eslint --ext .js,.vue src &gt; log.txt。 分析通过对输出的文件分析，我们项目的错误（警告）有以下几种 报错 规则 规则 Unexpected trailing comma comma-dangle 对象结尾跟随了一个多余的逗号 Expected ‘===’ and instead saw ‘==’ eqeqeq 必须使用全等 ‘util’ is not defined no-undef 不能有声明后未被使用的变量或参数 ‘delSpace’ is defined but never used no-unused-vars 不能有声明后未被使用的变量或参数 Elements in iteration expect to have ‘v-bind:key’ directives vue/require-v-for-key v-for中需v-bind:key Unexpected console statement no-console no-console]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS函数参数值校验]]></title>
    <url>%2F2018%2F09%2F27%2FJS%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%80%BC%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[在ES6中，为函数增加了参数默认值的特性，可以为参数设定一些默认值，可以让代码更简洁，可维护。 其实，我们可以通过这个特性来做函数参数值的校验。 首先，函数的参数可以是任意类型的值，也可以是函数，比如下面这个：123456789101112131415function fix(a = getA()) &#123; console.log('a', a)&#125;function getA() &#123; console.log('get a') return 2&#125;fix(1);// a 1fix();// get a// a 2 可以看出，如果在调用fix 时传了参数a，则不会执行函数getA，只有当不传递参数a时，才会执行函数getA。 这时候，我们可以利用这一特性，为参数a添加一个必传的校验，代码如下：12345678910111213function fix(a = require()) &#123; console.log('a', a)&#125;function require() &#123; throw new Error('缺少了参数 a')&#125;fix(1);// a 1fix();// Uncaught Error: 缺少了参数 a]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从进程谈JS运行机制]]></title>
    <url>%2F2018%2F09%2F27%2F%E4%BB%8E%E8%BF%9B%E7%A8%8B%E8%B0%88JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程和线程 进程之间相互独立。 一个进程由一个或多个线程组成。 多个线程在进程中协作完成任务。 同一进程下的各个线程之间共享程序的内存空间。 进程是cpu资源分配的最小单位。 线程是cpu调度的最小单位。 浏览器是多进程的 浏览器每打开一个tab标签页，任务管理器会多加一条记录。 浏览器包含哪些进程 Browser进程主进程，只有一个作用：用户交互，如前进，后退。页面的管理，创建和销毁其他进程。网络资源管理，下载。 第三方插件进程 GPU进程用于3D绘制 浏览器渲染进程（浏览器内核）Renderer进程，内部是多线程的 浏览器内核（渲染进程） 页面的渲染，JS的执行，事件的循环，都在这个进程内进行。 渲染进程是多线程的 浏览器渲染进程包含的线程 GUI渲染线程&ensp; &ensp; 解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。&ensp; &ensp; 注：GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程&ensp; &ensp; 例如V8引擎。 事件触发线程&ensp; &ensp; 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）。&ensp; &ensp; 当JS引擎执行如setTimeOut、AJAX异步请求等时，会将对应任务添加到事件线程中。&ensp; &ensp; 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。&ensp; &ensp; 由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。 定时触发器线程&ensp; &ensp; setInternal与 setTimeout所在线程。&ensp; &ensp; 浏览器定时计数器并不是由JavaScript引擎计数的。&ensp; &ensp; 通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）。&ensp; &ensp; 规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程&ensp; &ensp; XMLHttpRequest在连接后通过新开一个线程请求。&ensp; &ensp; 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 Browser进程和浏览器内核（Renderer进程）的通信过程 Browser进程收到用户请求，获取页面内容（如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程。 Renderer进程收到消息，简单解释后，交给渲染线程，然后开始渲染。&ensp; &ensp; 渲染线程接收请求，加载网页并渲染网页。&ensp; &ensp; 可能会有JS线程操作DOM（这样可能会造成回流并重绘）。&ensp; &ensp; 最后Render进程将结果传递给Browser进程。 Browser进程接收到结果并将结果绘制出来。 GUI渲染线程与JS引擎线程互斥 当JS引擎执行时GUI线程会被挂起 巨量计算阻塞页面加载 WebWorker 应对cpu密集型计算 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM） JS引擎线程与worker线程间通过特定的方式通信 JS引擎是单线程的，本质仍然未改变 浏览器渲染流程 解析html建立dom树 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树） 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 从Event Loop谈JS的运行机制概念： JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到执行栈中，开始执行。 定时器定时器是JS引擎检测的么？当然不是了。它是由定时器线程控制（因为JS引擎自己都忙不过来，根本无暇分身）。123setTimeout(function()&#123; console.log('hello!');&#125;,1000); 1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行。 123setTimeout(function()&#123; console.log('hello!');&#125;,0); 以最快的时间内将回调函数推入事件队列中，等待主线程执行。 W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 setTimeout而不是setInterval setInterval是每次都精确的隔一段时间推入一个事件 但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了。 致命问题：累计效应 macrotask与microtask12345678910111213console.log('script start');setTimeout(function()&#123; console.log('setTimeout');&#125;,0);Promise.resolve().then(function()&#123; console.log('promise1');&#125;).then(function()&#123; console.log('promise2');&#125;);console.log('script end'); 正确结果：12345script startscript endpromise1promise2setTimeout 因为Promise里有了一个一个新的概念： microtask JS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task定义和区别 macrotask（又称之为宏任务）&ensp; &ensp; 可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。&ensp; &ensp; 每一个macrotask会从头到尾将这个任务执行完毕，不会执行其它。&ensp; &ensp; 浏览器为了能够使得JS内部macrotask与DOM任务能够有序的执行，会在一个macrotask执行结束后，在下一个macrotask执行开始前，对页面进行重新渲染。（task-&gt;渲染-&gt;task-&gt;...） microtask（又称为微任务）&ensp; &ensp; 可以理解是在当前macrotask执行结束后立即执行的任务。&ensp; &ensp; 也就是说，在当前macrotask任务后，下一个macrotask之前，在渲染之前。&ensp; &ensp; 所以它的响应速度相比setTimeout（setTimeout是macrotask）会更快。 场景 macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask） microtask：Promise，process.nextTick等 总结]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[background-attachment实现滚动视差]]></title>
    <url>%2F2018%2F09%2F27%2Fbackground-attachment%E5%AE%9E%E7%8E%B0%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[background-attachment实现滚动视差background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动。 值 描述 scroll 默认值。背景图像会随着页面其余部分的滚动而移动。 fixed 当页面的其余部分滚动时，背景图像不会移动。 效果]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JOSN.stringfy小技巧]]></title>
    <url>%2F2018%2F09%2F27%2FJOSN.stringfy%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[JSON.stringify()的另外两个参数JSON.stringify(value[, replacer [, space]])参数： value：将要被序列化的变量的值 replacer：替代器。如果该参数是一个函数，则被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的JSON字符串中 space：指定缩进用的空白字符串，用于美化输出，可以是数字或者字符串。如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格； 使用函数过滤并序列化对象：123456789101112131415161718// 使用“函数”当替代器function replacer(key, value) &#123; if (typeof value === "string") &#123; return undefined; &#125; return value;&#125;let foo = &#123; foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7&#125;;let jsonString = JSON.stringify(foo, replacer);// &#123;"week":45,"month":7&#125; 使用数组过滤并序列化对象：12345678910111213141516// 使用“数组”当替代器let user = &#123; name: 'zollero', nick: 'z', skills: ['JavaScript', 'CSS', 'HTML5']&#125;;JSON.stringify(user, ['name', 'skills'], 2);// "&#123;// "name": "zollero",// "skills": [// "JavaScript",// "CSS",// "HTML5"// ]// &#125;" 对象的toJSON属性如果一个对象有toJSON属性，当它被序列化的时候，不会对该对象进行序列化，而是将它的toJSON方法的返回值进行序列化。 例子：12345678let obj = &#123; foo: 'foo', toJSON: function () &#123; return 'bar'; &#125;&#125;;JSON.stringify(obj); // '"bar"'JSON.stringify(&#123;x: obj&#125;); // '&#123;"x":"bar"&#125;']]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS函数收藏]]></title>
    <url>%2F2018%2F09%2F27%2FJS%E5%87%BD%E6%95%B0%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[Array.prototype.findIndex()返回数组中满足回调函数函数的第一个元素的索引。否则返回-1。 语法arr.findIndex(callback)举例：返回对象数组中value出现的索引123let index=arr.findIndex((item)=&gt;&#123; return item.value===value;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构赋值和拓展运算符]]></title>
    <url>%2F2018%2F09%2F27%2F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%92%8C%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[用解构赋值过滤对象属性1234567891011// 过滤掉对象 types 中的 inner 和 outer 属性const &#123; inner, outer, ...restProps &#125; = &#123; inner: 'This is inner', outer: 'This is outer', v1: '1', v2: '2', v4: '3'&#125;;console.log(restProps);// &#123;v1: "1", v2: "2", v4: "3"&#125; 用解构赋值获取嵌套对象的属性从一堆嵌套很深的对象属性中，很方便地拿到我们想要的那一个。1234567891011121314151617// 通过解构赋值获取嵌套对象的值const car = &#123; model: 'bmw 2018', engine: &#123; v6: true, turbo: true, vin: 12345 &#125;&#125;;// 这里使用 ES6 中的简单写法，使用 &#123; vin &#125; 替代 &#123; vin: vin &#125;const modalAndVIN = (&#123; model, engine: &#123; vin &#125;&#125;) =&gt; &#123; console.log(`model: $&#123;model&#125;, vin: $&#123;vin&#125;`);&#125;modalAndVIN(car);// "model: bmw 2018, vin: 12345" 拓展运算符合并对象拓展运算符，可以用来解构数组，也可以用来解构对象，它可以将对象中的所有属性展开。 通过这个特性，我们可以做一些对象合并的操作。12345678910111213// 使用拓展运算符合并对象，在后面的属性会重写前面相同属性的值const obj1 = &#123; a: 1, b: 2, c: 3 &#125;;const obj2 = &#123; c: 5, d: 9 &#125;;const merged = &#123; ...obj1, ...obj2 &#125;;console.log(merged);// &#123;a: 1, b: 2, c: 5, d: 9&#125;const obj3 = &#123; a: 1, b: 2 &#125;;const obj4 = &#123; c: 3, d: &#123; e: 4, ...obj3 &#125; &#125;;console.log(obj4);// &#123;c: 3, d: &#123;a: 1, b: 2, e: 4&#125; &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo排坑实录]]></title>
    <url>%2F2018%2F09%2F21%2Fhexo%E6%8E%92%E5%9D%91%E5%AE%9E%E5%BD%95%2F</url>
    <content type="text"><![CDATA[hexo是什么hexo是基于Node.js的博客框架，支持 Markdown，可部署到 GitHub Pages。由于是基于Node.js的，因此对前端程序员天然友好。官网：https://hexo.io/zh-cn/安装部署教程网上较多，在此不再赘述，仅记录安装部署过程中遇到的坑及解决办法。 部署完毕后，githubPage打开显示404，项目setting中的githubPage项提示：The tag fancybox on line 77 in theme/landspace/README.md is not recognized Liquid tag解决办法：123rm -rf .deploy_githexo ghexo d 提示没有git仓库解决办法：运行git init 其他问题windows下尽量不使用cmd其他无法解决的问题建议去github issue看一看]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列组合的实现]]></title>
    <url>%2F2017%2F08%2F10%2F%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[PHP实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?php// 阶乘function factorial($n)&#123; return array_product(range(1,$n));&#125;// 排列数function A($n,$m)&#123; return factorial($n)/factorial($n-$m);&#125;// 组合数function C($n,$m)&#123; return A($n,$m)/factorial($m);&#125;/** * 排列 * @param array $a * 要排列的数构成的数组 * @param int $m * @return array * 返回所有的排列情况 */function arrangement($a, $m) &#123; $r = array(); $n = count($a); if ($m &lt;= 0 || $m &gt; $n) &#123; return $r; &#125; for ($i=0; $i&lt;$n; $i++) &#123; $b = $a; $t = array_splice($b, $i, 1); if ($m == 1) &#123; $r[] = $t; &#125; else &#123; $c = arrangement($b, $m-1); foreach ($c as $v) &#123; $r[] = array_merge($t, $v); &#125; &#125; &#125; return $r;&#125;/** * 组合 * @param array $a * 要组合的数构成的数组 * @param int $m * @return array * 返回所有的组合情况 */function combination($a, $m) &#123; $r = array(); $n = count($a); if ($m &lt;= 0 || $m &gt; $n) &#123; return $r; &#125; for ($i=0; $i&lt;$n; $i++) &#123; $t = array($a[$i]); if ($m == 1) &#123; $r[] = $t; &#125; else &#123; $b = array_slice($a, $i+1); $c = combination($b, $m-1); foreach ($c as $v) &#123; $r[] = array_merge($t, $v); &#125; &#125; &#125; return $r;&#125; JavaScript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 创建范围为low至high的连续数组 * range(1,10)等同于php中的range方法 =&gt; [1,2,3,4,5,6,7,8,9,10] * @param low * @param high * @returns &#123;Array&#125; */function range(low, high) &#123; let arr = []; while (low &lt;= high) &#123; arr.push(low++); &#125; return arr;&#125;/** * 数组元素乘积 * 等同php中的array_product * @param arr * @returns &#123;*&#125; */function array_product(arr) &#123; return arr.reduce((pre, cur) =&gt; &#123; return pre * cur; &#125; );&#125;/** * 阶乘 * @param n * @returns &#123;*&#125; */function factorial(n) &#123; return array_product(range(1, n));&#125;/** * 排列数 * @param n * @param m * @returns &#123;number&#125; */function A(n, m) &#123; return factorial(n) / factorial(n - m);&#125;/** * 组合数 * @param n * @param m * @returns &#123;number&#125; */function C(n, m) &#123; return A(n, m) / factorial(m);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左旋转字符串]]></title>
    <url>%2F2017%2F08%2F08%2F%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ PHP： 123456789function LeftRotateString($str, $n)&#123; //字符串转换为数组 $arr = str_split($str); //数组切片，前n个字符放入shift数组，同时原数组删除这n个字符 $shift = array_splice($arr, 0, $n); //拼接两个数组，并转换为字符串 return implode('', array_merge($arr, $shift));&#125; JavaScript: 12345678function left(str, n) &#123; if (!str)&#123; return ''; &#125; let arr = str.split(''); let shift = arr.splice(0, n); return arr.concat(shift).join('');&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建乘积数组]]></title>
    <url>%2F2017%2F08%2F08%2F%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]\A[i+1]…A[n-1]。不能使用除法。 12345678910111213function multiply($numbers)&#123; $b = array(); //若原数组0个数大于1个，则用0填充b数组 if (array_count_values($numbers)[0] &gt; 1)&#123; return array_fill(0, count($numbers), 0); &#125; for ($i=0; $i&lt;count($numbers); $i++)&#123; //用差集，从原数组去除一个数 $b[$i] = array_product(array_diff($numbers, array_slice($numbers, $i, 1))); &#125; return $b;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口的最大值]]></title>
    <url>%2F2017%2F08%2F08%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 PHP： 1234567891011121314151617function maxInWindows($num, $size)&#123; if ($size &lt;= 0)&#123; return array(); &#125; //存放每个窗口内容 $result = array(); //存放各个最大值 $max = array(); for ($i=0; $i&lt;=count($num)-$size; $i++)&#123; $result[$i] = array_slice($num, $i, $size); &#125; foreach ($result as $key =&gt; $value) &#123; $max[$key] = max($value); &#125; return $max;&#125; JavaScript: 1234567891011121314151617181920function maxInWindows(number, size) &#123; if (size &lt;= 0)&#123; return []; &#125; let result = [], max = []; for (let i=0; i&lt;=number.length-size; i++)&#123; result[i] = number.slice(i, i+size); &#125; result.forEach( (val, key, arr) =&gt; &#123; max[key] = getMax(val); &#125; ); return max;&#125;function getMax(arr) &#123; return Math.max(...arr);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为S的两个数字]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述:对应每个测试案例，输出两个数，小的先输出。 123456789101112131415161718192021function FindNumbersWithSum($array, $sum)&#123; //存放和为sum的数组 $sumArray = array(); for ($i=0; $i&lt;count($array); $i++)&#123; for ($j=0; $j&lt;count($array); $j++)&#123; //遍历。若和为sum，压入数组 if (array_sum(array($array[$i], $array[$j])) == $sum)&#123; array_push($sumArray, array($array[$i], $array[$j])); &#125; &#125; &#125; //若不存在和为sum，返回空数组 if (empty($sumArray))&#123; return $sumArray; &#125; //sumArray数组中两数乘积最小对应的键名 $key=array_keys($sumArray, min($sumArray))[0]; //返回该两个数 return $sumArray[$key];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为S的连续正数序列]]></title>
    <url>%2F2017%2F07%2F11%2F%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 123456789101112function FindContinuousSequence($sum)&#123; $result=array(); for ($i=1; $i&lt;50; $i++)&#123; for ($j=$i+1; $j&lt;100; $j++)&#123; if (array_sum(range($i, $j)) == $sum)&#123; array_push($result,range($i, $j)); &#125; &#125; &#125; return $result;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用两个栈实现队列]]></title>
    <url>%2F2017%2F07%2F11%2F%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 123456789101112131415161718192021222324//两个栈global $arr1;$arr1 = array();global $arr2;$arr2 = array();function mypush($node)&#123; global $arr1; array_push($arr1, $node);&#125;function mypop()&#123; global $arr1; global $arr2; if (empty($arr2))&#123; while (!empty($arr1))&#123; $node = array_pop($arr1); array_push($arr2, $node); &#125; &#125; return array_pop($arr2);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非递归实现斐波那契数列]]></title>
    <url>%2F2017%2F07%2F11%2F%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39。有时间内存限制 123456789101112131415161718function Fibonacci($n)&#123; $a = 1; $b = 1; if ($n == 0)&#123; return 0; &#125;elseif ($n == 1 || $n == 2)&#123; return 1; &#125; else&#123; for ($i=3; $i&lt;=$n; $i++)&#123; $c = $a + $b; $a = $b; $b = $c; &#125; return $c; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把数组排成最小的数]]></title>
    <url>%2F2017%2F07%2F10%2F%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 1234567891011121314151617181920212223242526272829303132333435363738function PrintMinNumber($numbers)&#123; $result = array(); //全排列，每一种为一个数组 $arr = arrangement($numbers, count($numbers)); //对全排列中的每一种，拼接数组，放到数组result中 for ($i=0; $i&lt;count($arr); $i++)&#123; $result[$i] = implode($arr[$i]); &#125; //返回数组中的最小值 return min($result);&#125; //排列function arrangement($a, $m) &#123; $r = array(); $n = count($a); if ($m &lt;= 0 || $m &gt; $n) &#123; return $r; &#125; for ($i=0; $i&lt;$n; $i++) &#123; $b = $a; $t = array_splice($b, $i, 1); if ($m == 1) &#123; $r[] = $t; &#125; else &#123; $c = arrangement($b, $m-1); foreach ($c as $v) &#123; $r[] = array_merge($t, $v); &#125; &#125; &#125; return $r;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 一行代码可以做的事]]></title>
    <url>%2F2017%2F04%2F18%2FPython%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E5%81%9A%E7%9A%84%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[求1到10中所有偶数的平方 12L = [i*i for i in range(1, 11) if i%2 == 0]print(L) 生成全排列 12L = [m+n for m in 'ABC' for n in 'XYZ']print(L) 列出当前目录下的所有文件和目录名 123import osL = [d for d in os.listdir('.')]print(L) 把序列[1, 3, 5, 7, 9]变换成整数13579 123def f(x, y): return x*10+yprint(reduce(f, [1,3,5,7,9])) 求1到100的素数 1234567def prime(s): for n in range(2,s): if s % n == 0: return False return Trueprint filter(prime,range(2,101))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尾递归优化]]></title>
    <url>%2F2017%2F04%2F18%2F%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原文地址：廖雪峰的Python教程——递归函数 阶乘 1234def fact(n): if n == 1: return 1 return n * fact(n - 1) 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)： 1234567&gt;&gt;&gt; fact(1000)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 4, in fact ... File "&lt;stdin&gt;", line 4, in factRuntimeError: maximum recursion depth exceeded 解决递归调用栈溢出的方法是通过尾递归优化。 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中： 1234567def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) 可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。 fact(5)对应的fact_iter(5, 1)的调用如下： 123456===&gt; fact_iter(5, 1)===&gt; fact_iter(4, 5)===&gt; fact_iter(3, 20)===&gt; fact_iter(2, 60)===&gt; fact_iter(1, 120)===&gt; 120 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。 遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python坑之——默认参数必须指向不变对象]]></title>
    <url>%2F2017%2F04%2F18%2FPython%E5%9D%91%E4%B9%8B%E2%80%94%E2%80%94%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%BF%85%E9%A1%BB%E6%8C%87%E5%90%91%E4%B8%8D%E5%8F%98%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[原文地址：廖雪峰的Python教程——函数的参数 先定义一个函数，传入一个list，添加一个END再返回： 123def add_end(L = []): L.append('END') return L 当你正常调用时，结果似乎不错： 1234&gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, 'END']&gt;&gt;&gt; add_end(['x', 'y', 'z'])['x', 'y', 'z', 'END'] 当你使用默认参数调用时，一开始结果也是对的： 12&gt;&gt;&gt; add_end()['END'] 但是，再次调用add_end()时，结果就不对了： 1234&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END'] 默认参数是[]，但是函数似乎每次都“记住了”上次添加了&#39;END&#39;后的list。 原因解释如下： Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。 所以，定义默认参数要牢记一点：默认参数必须指向不变对象！ 要修改上面的例子，我们可以用None这个不变对象来实现： 12345def add_end(L = None): if L is None: L = [] L.append('END') return L 现在，无论调用多少次，都不会有问题： 1234&gt;&gt;&gt; add_end()['END']&gt;&gt;&gt; add_end()['END']]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python所有库]]></title>
    <url>%2F2017%2F04%2F17%2FPython%E6%89%80%E6%9C%89%E5%BA%93%2F</url>
    <content type="text"><![CDATA[http://www.lfd.uci.edu/~gohlke/pythonlibs/ 搜索需要的库，点击下载，将后缀改为zip并解压。将解压后的文件夹复制到python安装目录的lib文件夹下。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左旋转字符串]]></title>
    <url>%2F2017%2F04%2F14%2FPHP%20date()%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E4%B8%8D%E5%AF%B9%E6%80%8E%E4%B9%88%E5%8A%9E%2F</url>
    <content type="text"><![CDATA[使用PHP获取系统时间，发现时间不对，是因为PHP默认的时区是UTC，应该将其时区设置为北京时间。 方法一：修改php.ini文件打开php.ini文件：鼠标左键点击右下角的WampServer图标——PHP——php.ini,查找date.timezone，找到date.timezone =”UTC”，将其改为date.timezone =”PRC”，若date.timezone左边有分号，要将该分号去掉。 方法二：使用date_default_timezone_set(&#39;&#39;)方法 1234&lt;?php date_default_timezone_set('PRC'); echo date("Y-m-d H:i:s");?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全和可重入的区别]]></title>
    <url>%2F2017%2F04%2F14%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[源出处：http://waret.iteye.com/blog/744169 线程安全函数 概念：线程安全的概念比较直观。一般说来，一个函数被称为线程安全的，当且仅当被多个并发线程反复调用时，它会一直产生正确的结果。 确保线程安全：要确保函数线程安全，主要需要考虑的是线程之间的共享变量。属于同一进程的不同线程会共享进程内存空间中的全局区和堆，而私有的线程空间则主要包括栈和寄存器。因此，对于同一进程的不同线程来说，每个线程的局部变量都是私有的，而全局变量、局部静态变量、分配于堆的变量都是共享的。在对这些共享变量进行访 问时，如果要保证线程安全，则必须通过加锁的方式。 线程不安全的后果：线程不安全可能导致的后果是显而易见的——共享变量的值由于不同线程的访问，可能发生不可预料的变化，进而导致程序的错误，甚至崩溃。 可重入函数 概念：可重入的概念基本没有比较正式的完整解释，多数的文档都只是说明什么样的情况才能保证函数可重入，但没有完整定义。按照Wiki上的说法，“A computer program or routine is described as reentrant if it can be safely executed concurrently; that is, the routine can be re-entered while it is already running.”根据笔者的经验，所谓“重入”，常见的情况是，程序执行到某个函数foo()时，收到信号，于是暂停目前正在执行的函数，转到信号处理 函数，而这个信号处理函数的执行过程中，又恰恰也会进入到刚刚执行的函数foo()，这样便发生了所谓的重入。此时如果foo()能够正确的运行，而且处 理完成后，之前暂停的foo()也能够正确运行，则说明它是可重入的。 确保可重入：要确保函数可重入，需满足以下几个条件： 不在函数内部使用静态或全局数据 不返回静态或全局数据，所有数据都由函数的调用者提供。 使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。 不调用不可重入函数。 不可重入的后果：不可重入的后果主要体现在象信号处理函数这样需要重入的情况中。如果信号处理函数中使用了不可重入的函数，则可能导致程序的错误甚至崩溃。 可重入与线程安全可重入与线程安全并不等同。一般说来，可重入的函数一定是线程安全的，但反过来不一定成立。它们的关系可用下图来表示： 我们可以采用下面的变化过程来进一步说明上图： 如果一个函数中用到了全局或静态变量，那么它不是线程安全的，也不是可重入的； 如果我们对它加以改进，在访问全局或静态变量时使用互斥量或信号量等方式加锁，则可以使它变成线程安全的，但此时它仍然是不可重入的，因为通常加锁方式是针对不同线程的访问，而对同一线程可能出现问题； 如果将函数中的全局或静态变量去掉，改成函数参数等其他形式，则有可能使函数变成既线程安全，又可重入。 比如：strtok函数是既不可重入的，也不是线程安全的；加锁的strtok不是可重入的，但线程安全；而strtok_r既是可重入的，也是线程安全的。 注转载的这篇对可重入函数的定义说得太模糊，下面是关于”可重入函数“更全面和准确的描述： 在多线程或有异常控制流的情况下,当某个函数运行到中途时,控制流(也就是当前指令序列)就有可能被打断而去执行另一个函数.而”另一个函数”很有可能是它本身.，如果在这种情况下不会出现问题,比如说数据或状态不会被破坏，行为确定。那么这个函数就被称做”可重入”的.函数是可重入（reentrant）的，是指对于相同的（并且合法的）函数参数（包括无参函数的情况），多次重复调用此函数产生的行为是可预期的，即函数的行为一致，或者结果相同。不能保证这一点的函数称为不可重入（non-reentrant）函数。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP缓存机制]]></title>
    <url>%2F2016%2F10%2F18%2FPHP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[使用php自身的缓存机制 如果要测试php自己的缓存机制, 需要配置php.ini文件 123display_errors=Onoutput_buffering=Offerror_reporting= 设置错误级别 两种缓冲区：outputbuffer和程序缓存ob缓存关闭以后就放到程序缓存，程序缓存必须放到header后面，否则报错 函数： 12345ob_start(); //开启缓存ob_clean(); //清空 outputbuffer的内容ob_end_clean(); //关闭ob缓存，同时清空ob_flush(); //输出ob内容，并清空,但不关闭ob_end_flush(); //把ob缓存的内容输出,并关闭ob 测试题： 123456789&lt;?php ob_start();echo "abc";header("content-type:text/html;charset=utf-8");echo "hello"; ob_clean();echo "aa";header("content-type:text/html;charset=utf-8");?&gt; 输出：aa不报错没有关闭，aa放入ob 123456789&lt;?php ob_start(); echo "abc";header("content-type:text/html;charset=utf-8");echo "hello"; ob_end_clean();echo "aa";header("content-type:text/html;charset=utf-8");?&gt; 输出：aa报错aa放入的是程序缓存 123456789&lt;?php ob_start(); echo "abc";header("content-type:text/html;charset=utf-8");echo "hello"; ob_flush();echo "aa";echo ob_get_contents();?&gt; 输出：abchelloaaaa等待后面的一起输出 123456789&lt;?php ob_start(); echo "abc";header("content-type:text/html;charset=utf-8");echo "hello"; ob_end_flush();echo "aa";echo ob_get_contents();?&gt; 输出：abchelloaaabchelloaa最后再关闭]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[require、require_once、include、include_once区别]]></title>
    <url>%2F2016%2F10%2F11%2Frequire%E3%80%81require_once%E3%80%81include%E3%80%81include_once%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[require_once 和 include_once 在执行时只对包含的文件执行一次，即使在代码中调用多次。 include和include_once若包含失败，显示警告错误（warning error），然后继续执行。require和require_once若包含失败，抛出致命错误（fatal error），中止执行。开发严谨应用时，应用require和require_once。 实际中，千万别把错误信息抛给用户，可在代码中使用error_reporting(0)禁止错误显示。 性能角度，使用require要快于require_once]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[empty、isset、is_null的区别]]></title>
    <url>%2F2016%2F10%2F11%2Fempty%E3%80%81isset%E3%80%81is_null%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[isset()用来检测一个变量是否已声明且值不为NULL。即，只有在变量值不为NULL时返回真。 empty()用来检测一个变量是否为空，即如下情况返回真：变量是空字符串，false，空数组[array()]，NULL，0，’‘，以及被unset删除后的变量。 is_null()用来判断变量内容是否为NULL值，即仅为变量是NULL时返回真。 如表格所示，空白表示返回false]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2环境配置]]></title>
    <url>%2F2016%2F05%2F20%2FStruts2%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[导入jar包导入struts.xml文件删除多余代码。若得不到相应提示，http://struts.apache.org/dtds/struts-2.3.dtd dtd文件未找到。会在联网时自动下载dtd文件。 dtd文件手动导入。打开Window—Perferences，进入XML Catalog，点击add。 配置web.xml文件，配置核心过滤器12345678910&lt;filter&gt; &lt;filter-name&gt;Struts2Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;Struts2Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语法推导树之短语，直接短语，句柄]]></title>
    <url>%2F2015%2F03%2F05%2F%E8%AF%AD%E6%B3%95%E6%8E%A8%E5%AF%BC%E6%A0%91%E4%B9%8B%E7%9F%AD%E8%AF%AD%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%9F%AD%E8%AF%AD%EF%BC%8C%E5%8F%A5%E6%9F%84%2F</url>
    <content type="text"><![CDATA[概念 短语：任意一颗子树中，如果根结点经过若干步才推导出了叶子结点，则这些叶子结点组成的序列就是相对于这棵子树的短语 直接短语：属于短语，只不过不能经过若干步的推导了，必须一步就能推导出来叶子结点来，这些叶子结点组成的序列才是相对于这颗子树的直接短语 句柄：属于直接短语，它是这些有直接短语的子树中最左边的那颗子树的直接短语 例子找出下面的这颗语法推导树的短语，直接短语，句柄。 找出这棵树的所有子树 找出每一颗子树的短语 第1棵：a1ɛb1b2a2a3 第2棵：ɛb1b2 第3棵：a2a3 第4棵：a1 第5棵：ɛ 第6棵：b1 第7棵：b2 第8棵：a2 找出每一颗子树的直接短语 第1棵：因为这棵树的叶子结点是经过若干步推导出来的没有一步就推导出来的，所以没有直接短语 第2棵：同上 第3棵：同上，虽然a3是直接推导出来的，但是a2不是，所以它们组成的序列不能说是直接短语 第4棵：a1 第5棵：ɛ 第6棵：b1 第7棵：b2 第8棵：a2 从这些直接短语中找那个排在最左边的直接短语，即句柄，这道题的句柄就是a1]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[怎样求First集与Follow集]]></title>
    <url>%2F2015%2F03%2F05%2F%E6%80%8E%E6%A0%B7%E6%B1%82First%E9%9B%86%E4%B8%8EFollow%E9%9B%86%2F</url>
    <content type="text"><![CDATA[文法： S→ABc A→a\ ε B→b\ ε First集合求法: 能 由非终结符号推出的所有的开头符号或可能的ε，但要求这个开头符号是终结符号。如此题A可以推导出a和ε，所以FIRST（A）=｛a，ε｝；同理 FIRST（B）={b,ε};S可以推导出aBc，还可以推导出bc，还可以推导出c，所以FIRST(S）=｛a，b，c｝ Follow集合的求法: 紧跟随其后面的终结符号或＃。但文法的识别符号包含＃，在求的时候还要考虑到ε。 具体做法是把所有包含你要求的符号的产生式都找出来，再看哪个有用。 Follow（S）=｛＃｝ 如求A的，产生式：S→ABc A→a\ ε ，但只有S→ABc 有用。跟随在A后年的终结符号是FIRST（B）=｛b，ε｝，当FIRST（B）的元素为ε时，跟随在A后的符号就是c，所以 Follow（A）=｛b，c｝ 同理Follow（B）=｛c｝ 一，要知道什么是终结符和非终结符 终结符：通俗的说就是不能单独出现在推导式左边的符号，也就是说终结符不能再进行推导。 非终结符：不是终结符的都是非终结符。（非男即女，呵呵） 如：A——&gt;B，则A是非终结符。 （一般书上终结符用小写，非终结符用大写。） 二，文法产生语言句子的基本思想：从识别符号（开始符）开始，把当前产生的符号串中的非终结符替换为相应规则右部的符号串，直到全部由终结符组成。 三，FIRST集求法 ​ First集合最终是对产生式右部的字符串而言的，但其关键是求出非终结符的First集合，由于终结符的First集合就是它自己，所以求出非终结符的First集合后，就可很直观地得到每个字符串的First集合。 \1. 直接收取：对形如U－&gt;a…的产生式（其中a是终结符），把a收入到First(U)中 \2. 反复传送：对形入U－&gt;P…的产生式（其中P是非终结符），应把First(P)中的全部内容传送到First(U)中【意思就是只需要把第一个非终结符的First集传过去~这个地方是要注意的地方，也是难点】。 四，FOLLOW集的求法 ​ Follow集合是针对非终结符而言的，Follow(U)所表达的是句型中非终结符U所有可能的后随终结符号的集合，特别地，“#”是识别符号的后随符。注意Follow集合是从开始符号S开始推导。 直接收取：注意产生式右部的每一个形如“…Ua…”的组合，把a直接收入到Follow(U)中。因a是紧跟在U后的终结符。 直接收取：对形如“…UP…”(P是非终结符)的组合，把First(P)直接收入到Follow(U)中【在这里，如果First（P）中有空字符，那么就要把左部（假设是S）的Follow（S）送入到Follow（U）中。还有就是Follow集中是没有空字符的】。 直接收取：若S－&gt;…U，即以U结尾，则#∈Follow(U) 反复传送：对形如U－&gt;…P的产生式（其中P是非终结符），应把Follow(U)中的全部内容传送到Follow(P)中。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
</search>
