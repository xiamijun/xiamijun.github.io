<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小程序系列一——小程序部署手册]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[申请账号点击https://mp.weixin.qq.com/wxopen/waregister?action=step1 申请账号 注册成功后，可登陆微信公众平台https://mp.weixin.qq.com](https://mp.weixin.qq.com)在菜单 设置-开发设置 看到小程序的 AppID 了 。 创建项目新建项目时，选择空白文件夹，可创建quickStart示例项目。 目录结构其目录结构如下所示： 1234567891011121314151617181920project│ app.js ----------------------------程序入口│ app.json --------------------------全局配置│ app.wxss --------------------------全局样式│ project.config.json ----------------项目配置│ ├─pages --------------------------------页面文件夹│ ├─index│ │ index.js --------------------js│ │ index.wxml ------------------html│ │ index.wxss ------------------css│ │ │ └─logs│ logs.js│ logs.json ------------------页面配置│ logs.wxml│ logs.wxss│ └─utils --------------------------------工具类 util.js json配置配置页面路径、窗口表现、设置多 tab 等。 单个页面的json配置只有window一项。 app.js程序入口。 App() 必须在app.js中调用，必须调用且只能调用一次。接受一个 Object 参数，其指定小程序的生命周期回调等。 还可以在app.js中定义全局变量。 示例代码中在初始化小程序时，做了如下几件事。 1、调用 wx.login() 获取临时登录凭证code，可回传到开发者服务器。 2、使用 wx.getSetting() 获取用户当前的授权状态。 3、调用接口 wx.getUserInfo() ，获取用户信息。 发布准备团队身份管理可在微信公众平台统一管理项目成员、设置项目成员的权限。 入口：用户身份 – 成员管理 权限说明： 权限 说明 开发者权限 可使用小程序开发者工具进行开发 体验者权限 可使用体验版小程序 登录 可登录小程序管理后台，无需管理员确认 数据分析 使用小程序数据分析功能查看小程序数据 开发管理 小程序提交审核、发布、回退 开发设置 设置小程序服务器域名、消息推送 暂停服务设置 暂停小程序线上服务 服务器配置每个小程序需要事先设置通讯域名，小程序可以跟指定的域名与进行网络通信。包括普通 HTTPS 请求（request）、上传文件（uploadFile）、下载文件（downloadFile) 和 WebSocket 通信（connectSocket）。 在微信公众平台 - 设置 - 开发设置 - 服务器域名中，可配置服务器域名。 必须使用https请求 域名不能使用 IP 地址或 localhost 域名必须经过 ICP 备案 不校验合法域名若是请求不合法域名，会在控制台报错xxx不在以下 request 合法域名列表中，并无法请求。 在开发阶段，可以手动开启不校验合法域名。 开发者工具菜单设置 - 项目设置中勾选不校验合法域名。发出请求可以收到返回数据，控制台报一条警告。 预览使用开发者工具可以预览小程序。 点击开发者工具顶部预览按钮，开发者工具会自动打包当前项目，并上传小程序代码至微信的服务器，成功之后会在界面上显示一个二维码。使用当前小程序开发者的微信扫码即可看到小程序在手机客户端上的真实表现。 上传代码同预览不同，上传代码是用于提交体验或者审核使用的。 点击开发者工具顶部操作栏的上传按钮，填写版本号以及项目备注。上传成功之后，登录微信公众平台 - 开发管理 - 开发版本 就可以找到刚提交上传的版本了。 版本管理 版本 说明 开发版本 使用开发者工具，可将代码上传到开发版本中。开发版本只保留每人最新的一份上传代码。可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。 体验版本 供测试人员和产品经理测试的版本。可将开发版本选为体验版本。 审核中版本 只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。 线上版本 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。 上线填写基本信息小程序须先完成小程序基本资料填写后，方可提交审核。入口：微信公众平台 - 设置 - 基本设置 提交审核微信公众平台 - 开发管理 - 开发版本中提交审核，填写相关信息。 提交完毕后，可在审核版本中看到相关信息。 发布审核通过之后，管理员的微信中会收到审核通过的通知，此时登录 微信公众平台 - 开发管理 - 审核版本中可以看到通过审核的版本。 请点击发布，即可发布小程序。 发布完成后，可在 微信公众平台 - 设置 - 基本设置中下载自己小程序的二维码。（搜小程序名字暂时搜不到） 运营数据有两种方式可以方便的看到小程序的运营数据。 方法一： 登录 微信公众平台 - 数据分析 点击相应的 tab 可以看到相关的数据。 方法二： 使用小程序数据助手，在微信中方便的查看运营数据。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VsCode插件和配置]]></title>
    <url>%2F2018%2F11%2F12%2FVsCode%E6%8F%92%E4%BB%B6%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[插件通用Chinese (Simplified) Language Pack for Visual Studio Code适用于 VS Code 的中文（简体）语言包 安装后，在 locale.json 中添加 &quot;locale&quot;: &quot;zh-cn&quot;，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 Ctrl+Shift+P 打开命令面板，之后输入config` 筛选 JetBrains IDE KeymapwebStorm的快捷键 Path Intellisense文件路径提示 JSbeautify美化JS, JSON, CSS, Sass, 和HTML代码 按F1键选择Beautify file VueVeturVue代码高亮、格式化、自动补全、eslint检查 微信小程序minapp小程序标签、属性自动补全 vscode weapp api小程序 API 提示及代码片段 配置自动保存勾选文件-自动保存 代码片段Vue模板文件-首选项-用户代码片段-vue.json： 123456789101112131415161718192021222324&#123; "Print to console": &#123; "prefix": "vue", "body": [ "&lt;template&gt;", " &lt;div&gt;\n", " &lt;/div&gt;", "&lt;/template&gt;\n", "&lt;script&gt;", " export default &#123;", " data () &#123;", " return &#123;\n", " &#125;", " &#125;,", " &#125;", "&lt;/script&gt;\n", "&lt;style&gt;\n", " ", "&lt;/style&gt;", "$2" ], "description": "output Vue template" &#125;&#125;]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线程安全和可重入的区别]]></title>
    <url>%2F2018%2F10%2F16%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[源出处：http://waret.iteye.com/blog/744169 线程安全函数 概念：线程安全的概念比较直观。一般说来，一个函数被称为线程安全的，当且仅当被多个并发线程反复调用时，它会一直产生正确的结果。 确保线程安全：要确保函数线程安全，主要需要考虑的是线程之间的共享变量。属于同一进程的不同线程会共享进程内存空间中的全局区和堆，而私有的线程空间则主要包括栈和寄存器。因此，对于同一进程的不同线程来说，每个线程的局部变量都是私有的，而全局变量、局部静态变量、分配于堆的变量都是共享的。在对这些共享变量进行访 问时，如果要保证线程安全，则必须通过加锁的方式。 线程不安全的后果：线程不安全可能导致的后果是显而易见的——共享变量的值由于不同线程的访问，可能发生不可预料的变化，进而导致程序的错误，甚至崩溃。 可重入函数 概念：可重入的概念基本没有比较正式的完整解释，多数的文档都只是说明什么样的情况才能保证函数可重入，但没有完整定义。按照Wiki上的说法，“A computer program or routine is described as reentrant if it can be safely executed concurrently; that is, the routine can be re-entered while it is already running.”根据笔者的经验，所谓“重入”，常见的情况是，程序执行到某个函数foo()时，收到信号，于是暂停目前正在执行的函数，转到信号处理 函数，而这个信号处理函数的执行过程中，又恰恰也会进入到刚刚执行的函数foo()，这样便发生了所谓的重入。此时如果foo()能够正确的运行，而且处 理完成后，之前暂停的foo()也能够正确运行，则说明它是可重入的。 确保可重入：要确保函数可重入，需满足以下几个条件： 不在函数内部使用静态或全局数据 不返回静态或全局数据，所有数据都由函数的调用者提供。 使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。 不调用不可重入函数。 不可重入的后果：不可重入的后果主要体现在象信号处理函数这样需要重入的情况中。如果信号处理函数中使用了不可重入的函数，则可能导致程序的错误甚至崩溃。 可重入与线程安全可重入与线程安全并不等同。一般说来，可重入的函数一定是线程安全的，但反过来不一定成立。它们的关系可用下图来表示： 我们可以采用下面的变化过程来进一步说明上图： 如果一个函数中用到了全局或静态变量，那么它不是线程安全的，也不是可重入的； 如果我们对它加以改进，在访问全局或静态变量时使用互斥量或信号量等方式加锁，则可以使它变成线程安全的，但此时它仍然是不可重入的，因为通常加锁方式是针对不同线程的访问，而对同一线程可能出现问题； 如果将函数中的全局或静态变量去掉，改成函数参数等其他形式，则有可能使函数变成既线程安全，又可重入。 比如：strtok函数是既不可重入的，也不是线程安全的；加锁的strtok不是可重入的，但线程安全；而strtok_r既是可重入的，也是线程安全的。 注转载的这篇对可重入函数的定义说得太模糊，下面是关于”可重入函数“更全面和准确的描述： 在多线程或有异常控制流的情况下,当某个函数运行到中途时,控制流(也就是当前指令序列)就有可能被打断而去执行另一个函数.而”另一个函数”很有可能是它本身.，如果在这种情况下不会出现问题,比如说数据或状态不会被破坏，行为确定。那么这个函数就被称做”可重入”的.函数是可重入（reentrant）的，是指对于相同的（并且合法的）函数参数（包括无参函数的情况），多次重复调用此函数产生的行为是可预期的，即函数的行为一致，或者结果相同。不能保证这一点的函数称为不可重入（non-reentrant）函数。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python所有库]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E6%89%80%E6%9C%89%E5%BA%93%2F</url>
    <content type="text"><![CDATA[http://www.lfd.uci.edu/~gohlke/pythonlibs/ 搜索需要的库，点击下载，将后缀改为zip并解压。将解压后的文件夹复制到python安装目录的lib文件夹下。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python坑之——默认参数必须指向不变对象]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E5%9D%91%E4%B9%8B%E2%80%94%E2%80%94%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%BF%85%E9%A1%BB%E6%8C%87%E5%90%91%E4%B8%8D%E5%8F%98%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[原文地址：廖雪峰的Python教程——函数的参数 先定义一个函数，传入一个list，添加一个END再返回： 123def add_end(L = []): L.append('END') return L 当你正常调用时，结果似乎不错： 1234&gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, 'END']&gt;&gt;&gt; add_end(['x', 'y', 'z'])['x', 'y', 'z', 'END'] 当你使用默认参数调用时，一开始结果也是对的： 12&gt;&gt;&gt; add_end()['END'] 但是，再次调用add_end()时，结果就不对了： 1234&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END'] 默认参数是[]，但是函数似乎每次都“记住了”上次添加了&#39;END&#39;后的list。 原因解释如下： Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。 所以，定义默认参数要牢记一点：默认参数必须指向不变对象！ 要修改上面的例子，我们可以用None这个不变对象来实现： 12345def add_end(L = None): if L is None: L = [] L.append('END') return L 现在，无论调用多少次，都不会有问题： 1234&gt;&gt;&gt; add_end()['END']&gt;&gt;&gt; add_end()['END']]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尾递归优化]]></title>
    <url>%2F2018%2F10%2F16%2F%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原文地址：廖雪峰的Python教程——递归函数 阶乘 1234def fact(n): if n == 1: return 1 return n * fact(n - 1) 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)： 1234567&gt;&gt;&gt; fact(1000)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 4, in fact ... File "&lt;stdin&gt;", line 4, in factRuntimeError: maximum recursion depth exceeded 解决递归调用栈溢出的方法是通过尾递归优化。 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中： 1234567def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) 可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。 fact(5)对应的fact_iter(5, 1)的调用如下： 123456===&gt; fact_iter(5, 1)===&gt; fact_iter(4, 5)===&gt; fact_iter(3, 20)===&gt; fact_iter(2, 60)===&gt; fact_iter(1, 120)===&gt; 120 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。 遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 一行代码可以做的事]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E5%81%9A%E7%9A%84%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[求1到10中所有偶数的平方 12L = [i*i for i in range(1, 11) if i%2 == 0]print(L) 生成全排列 12L = [m+n for m in 'ABC' for n in 'XYZ']print(L) 列出当前目录下的所有文件和目录名 123import osL = [d for d in os.listdir('.')]print(L) 把序列[1, 3, 5, 7, 9]变换成整数13579 123def f(x, y): return x*10+yprint(reduce(f, [1,3,5,7,9])) 求1到100的素数 1234567def prime(s): for n in range(2,s): if s % n == 0: return False return Trueprint filter(prime,range(2,101))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把数组排成最小的数]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 1234567891011121314151617181920212223242526272829303132333435363738function PrintMinNumber($numbers)&#123; $result = array(); //全排列，每一种为一个数组 $arr = arrangement($numbers, count($numbers)); //对全排列中的每一种，拼接数组，放到数组result中 for ($i=0; $i&lt;count($arr); $i++)&#123; $result[$i] = implode($arr[$i]); &#125; //返回数组中的最小值 return min($result);&#125; //排列function arrangement($a, $m) &#123; $r = array(); $n = count($a); if ($m &lt;= 0 || $m &gt; $n) &#123; return $r; &#125; for ($i=0; $i&lt;$n; $i++) &#123; $b = $a; $t = array_splice($b, $i, 1); if ($m == 1) &#123; $r[] = $t; &#125; else &#123; $c = arrangement($b, $m-1); foreach ($c as $v) &#123; $r[] = array_merge($t, $v); &#125; &#125; &#125; return $r;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非递归实现斐波那契数列]]></title>
    <url>%2F2018%2F10%2F16%2F%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39。有时间内存限制 123456789101112131415161718function Fibonacci($n)&#123; $a = 1; $b = 1; if ($n == 0)&#123; return 0; &#125;elseif ($n == 1 || $n == 2)&#123; return 1; &#125; else&#123; for ($i=3; $i&lt;=$n; $i++)&#123; $c = $a + $b; $a = $b; $b = $c; &#125; return $c; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用两个栈实现队列]]></title>
    <url>%2F2018%2F10%2F16%2F%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 123456789101112131415161718192021222324//两个栈global $arr1;$arr1 = array();global $arr2;$arr2 = array();function mypush($node)&#123; global $arr1; array_push($arr1, $node);&#125;function mypop()&#123; global $arr1; global $arr2; if (empty($arr2))&#123; while (!empty($arr1))&#123; $node = array_pop($arr1); array_push($arr2, $node); &#125; &#125; return array_pop($arr2);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为S的连续正数序列]]></title>
    <url>%2F2018%2F10%2F16%2F%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 123456789101112function FindContinuousSequence($sum)&#123; $result=array(); for ($i=1; $i&lt;50; $i++)&#123; for ($j=$i+1; $j&lt;100; $j++)&#123; if (array_sum(range($i, $j)) == $sum)&#123; array_push($result,range($i, $j)); &#125; &#125; &#125; return $result;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为S的两个数字]]></title>
    <url>%2F2018%2F10%2F16%2F%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述:对应每个测试案例，输出两个数，小的先输出。 123456789101112131415161718192021function FindNumbersWithSum($array, $sum)&#123; //存放和为sum的数组 $sumArray = array(); for ($i=0; $i&lt;count($array); $i++)&#123; for ($j=0; $j&lt;count($array); $j++)&#123; //遍历。若和为sum，压入数组 if (array_sum(array($array[$i], $array[$j])) == $sum)&#123; array_push($sumArray, array($array[$i], $array[$j])); &#125; &#125; &#125; //若不存在和为sum，返回空数组 if (empty($sumArray))&#123; return $sumArray; &#125; //sumArray数组中两数乘积最小对应的键名 $key=array_keys($sumArray, min($sumArray))[0]; //返回该两个数 return $sumArray[$key];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口的最大值]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 PHP： 1234567891011121314151617function maxInWindows($num, $size)&#123; if ($size &lt;= 0)&#123; return array(); &#125; //存放每个窗口内容 $result = array(); //存放各个最大值 $max = array(); for ($i=0; $i&lt;=count($num)-$size; $i++)&#123; $result[$i] = array_slice($num, $i, $size); &#125; foreach ($result as $key =&gt; $value) &#123; $max[$key] = max($value); &#125; return $max;&#125; JavaScript: 1234567891011121314151617181920function maxInWindows(number, size) &#123; if (size &lt;= 0)&#123; return []; &#125; let result = [], max = []; for (let i=0; i&lt;=number.length-size; i++)&#123; result[i] = number.slice(i, i+size); &#125; result.forEach( (val, key, arr) =&gt; &#123; max[key] = getMax(val); &#125; ); return max;&#125;function getMax(arr) &#123; return Math.max(...arr);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建乘积数组]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]\A[i+1]…A[n-1]。不能使用除法。 12345678910111213function multiply($numbers)&#123; $b = array(); //若原数组0个数大于1个，则用0填充b数组 if (array_count_values($numbers)[0] &gt; 1)&#123; return array_fill(0, count($numbers), 0); &#125; for ($i=0; $i&lt;count($numbers); $i++)&#123; //用差集，从原数组去除一个数 $b[$i] = array_product(array_diff($numbers, array_slice($numbers, $i, 1))); &#125; return $b;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左旋转字符串]]></title>
    <url>%2F2018%2F10%2F16%2F%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ PHP： 123456789function LeftRotateString($str, $n)&#123; //字符串转换为数组 $arr = str_split($str); //数组切片，前n个字符放入shift数组，同时原数组删除这n个字符 $shift = array_splice($arr, 0, $n); //拼接两个数组，并转换为字符串 return implode('', array_merge($arr, $shift));&#125; JavaScript: 12345678function left(str, n) &#123; if (!str)&#123; return ''; &#125; let arr = str.split(''); let shift = arr.splice(0, n); return arr.concat(shift).join('');&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue最佳实践]]></title>
    <url>%2F2018%2F10%2F16%2FVue%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[化繁为简的Watch场景还原：12345678created()&#123; this.getData()&#125;,watch: &#123; inputValue()&#123; this.getData() &#125;&#125; 组件创建的时候我们获取一次列表数据，同时监听input框，每当发生变化的时候重新获取一次列表数据 优化：首先，在watchers中，可以直接使用函数的字面量名称；其次，声明immediate:true表示创建组件时立马执行一次。123456watch: &#123; searchInputValue:&#123; handler: &apos;fetchPostList&apos;, immediate: true &#125;&#125; DatePicker组件默认打开iView DatePicker组件，设置:open=&quot;true&quot;设置为默认打开。并用 1&lt;a href="javascript:void(0)"&gt;&lt;/a&gt; 隐藏默认的选择框。 .sync 修饰符.sync实际上是一个语法糖，用于实现父子组件间的数据双向绑定 用法：12345678//父组件&lt;child :childModalFlag.sync=&quot;showChildFlag&quot;&gt;&lt;/child&gt;data() &#123; return &#123; showWeekFlag: false &#125;&#125; 1234567891011121314151617//子组件&lt;Modal v-model=&quot;childModalFlag&quot;&gt;props:&#123; childModalFlag: &#123; required: true, type: Boolean &#125;&#125;methods:&#123; updateVisible(flag) &#123; this.childModalFlag = flag; this.$emit(&apos;update:childModalFlag&apos;, this.childModalFlag) // 更新对话框的显示状态 &#125;&#125; DatePicker组件判空element-ui DatePicker组件判空： value === &#39;&#39; || value === null Vuex 刷新失效Vuex在刷新以后，存储的数据会恢复原始状态。 因为Vuex是管理状态的工具，不是做持久存储的。 改用sessionStorage或localStorage DatePicker组件设置禁用范围12345678910111213&lt;el-date-picker :picker-options=&quot;pickerOptions&quot;&gt;&lt;/el-date-picker&gt;data()&#123; return &#123; pickerOptions: &#123; disabledDate(time) &#123; return time.getTime() &lt; Date.now() - 8.64e7; &#125; &#125; &#125;&#125; localhost改为IP地址package.json中改为： 123"scripts": &#123; "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js --host 10.4.0.217"&#125;, config/index.js中改为：host: &#39;10.4.0.217&#39;, 就可以在浏览器输入IP地址访问，局域网其他用户也可以访问 DatePicker 组件结束时间取值时应取endTime+1 通过ajax获取数据放到Select 选择器下拉选项中element-ui的Select组件 1234567data() &#123; return &#123; options: &#123; data: [] &#125; &#125;&#125; ajax回调里： 12345678let detail=[];data.list.forEach((i, v) =&gt; &#123; let obj = &#123;&#125;; obj.value = 'xx'; obj.label = 'xx'; detail.push(obj);&#125;);this.options.data = detail; template中： 1v-for=&quot;item in options.data&quot; Vue中使用echarts 需放在mounted中，因为需要取到DOM，不能放在created里。 不能用v-if，要用v-show，同理，DOM的问题。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件开发-测试-发布流程总结]]></title>
    <url>%2F2018%2F10%2F16%2FVue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91-%E6%B5%8B%E8%AF%95-%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[组件规范化开发要求 单文件组件开发（SFC） 单元测试实现 支持&lt;script&gt;及模块化规范引入 发布到npm 组件开发Vue组件开发规范 单元测试引入vue官方提供test-utils工具进行测试，并基于jest运行测试脚本。 编写单元测试脚本yourApp.spc.js： 打包构建虽然可以直接分享.vue文件，但这样会让那些想直接通过js引用的人无法使用，所以我们需要打包构建。 选择rollup打包，生成yourApp.umd.js到dist目录下，可直接引用。 发布到npm私服1234$ npm install nrm -g$ nrm add xxx http://xx.xx.xx.xx$ nrm use xxx$ npm publish]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用指南]]></title>
    <url>%2F2018%2F10%2F16%2Fhexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[什么是hexo基于Node.js的博客框架，使用Markdown解析文章 安装安装前提必须安装以下环境： Node.js Git 安装hexo$ npm install -g hexo-cli全局安装 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 目录结构12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml站点配置文件 scaffolds模板文件夹 page.md post.md draft.md source用户资源文件夹 _posts 文件夹存放md文件 themes主题文件夹 写作1`$ hexo new [layout] &lt;title&gt;` 自动生成名为test.md的markdown文件到_post文件夹下。 或者手动复制markdown文件至_post文件夹下，但需要手动添加头部信息： 123456---title: hexo使用指南date: 2018-10-16 10:39:26tags: 博客categories: 博客--- 更多展示在首页，多余部分隐藏： 1&lt;!--more--&gt; markdown语法的[TOC]目录，在hexo中无法展示 点击更多时，从头开始阅读： 1scroll_to_more: false 发布本地部署生成静态页面： 1`$ hexo generate` 或者简写： 1`$ hexo g` 启动服务器 1`$ hexo server` 或者简写： 1`$ hexo server` 提示： 1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 在浏览器中打开http://localhost:4000/ 部署到Github Page创建库新建一个名为yourname.github.io的库 在setting中开启github page 配置Deployment在_config.yml文件中，找到Deployment，然后按照如下修改，用户名改成自己的GitHub信息：需要注意的是：冒号后面记得空一格！ 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:xiamijun/xiamijun.github.io.git branch: master 提交12345678// 生成新的 public 文件hexo generate或者hexo g// 开始部署hexo deploye或者hexo d 排错 部署完毕后，githubPage打开显示404，项目setting中的githubPage项提示：The tag fancybox on line 77 in theme/landspace/README.md is not recognized Liquid tag 解决办法： 123rm -rf .deploy_githexo ghexo d 提示没有git仓库 解决办法： git init 其他报错 github issue 进阶解析到个人域名GitHub 仓库的根目录下建立一个 CNAME 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加http:// www.xxxxx.com 进入域名提供商地址，添加解析 注意：CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐 方法：通过安装插件实现永久保留 1$ npm install hexo-generator-cname --save 之后在_config.yml中添加一条 12plugins:- hexo-generator-cname Next主题hexo默认主题是landscape，可以更改为其他主题。 Next主题是目前较流行且成熟的主题。next主题文档 主题风格Next提供4个主题风格，选择自己想要的。 Muse Mist Pisces Gemini 更换头像代码高亮分类页新建分类页面 1hexo new page categories 给分类页面添加类型 在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。 12345---title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot; #这部分是新添加的--- 接下来的每篇文章中，都可以在头部添加分类信息： 12345---title: hexo使用指南date: 2018-10-16 10:39:26categories: 博客--- 标签页同样可以设置标签页 1hexo new page tags 给标签页面添加类型 在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。 123title: tagsdate: 2018-08-06 22:48:29type: &quot;tags&quot; #新添加的内容 接下来的每篇文章中，都可以在头部添加标签信息： 12345---title: hexo使用指南date: 2018-10-16 10:39:26tags: [博客,tag2]--- 修改底部建站信息修改主题的配置文件： 12345678910111213141516171819footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2018 # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). # version: true # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target=&quot;_blank&quot; href=&quot;https://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt; 隐藏hexo链接和Next链接 统计阅读次数使用LeanCloud的服务，具体方法参考教程,添加完之后效果如下： 注册LeanCloud帐号并验证邮箱之后，新建应用。 由于存在ACL权限问题，新建时选择无限制 左侧下划线开头的都是系统预定义好的表，新建一个表，名字必须为Counter 创建完成之后，左侧数据栏应该会多出一栏名为Counter的栏目 点击设置，选择应用Key，即可得到AppID以及AppKey 将其复制到主题配置文件： 1234leancloud_visitors: enable: true app_id: 111111-2222 app_key: 33333444 记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。 每次访问一篇文章后，Counter表就会多出一条字段，可以修改其中的time字段来修改阅读次数。 安全问题：在设置-安全中心-Web 安全域名中，填入自己的博客域名 字数统计与阅读时长打开/themes/next/layout/_macro/post.swig`文件 站内搜索安装插件 1npm install hexo-generator-searchdb --save 修改 主题配置文件 12local_search: enable: true 404页推荐用腾讯公益404页面，寻找丢失儿童，关注公益事业。 使用方法，新建404.html页面，放到主题的source目录下，内容如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 站点分析使用百度统计，注册百度统计，管理 &gt; 网站列表 &gt; 新增网站完成后，代码管理 &gt; 代码获取，就能得到统计id。 12# Baidu Analytics IDbaidu_analytics: 统计id 评论功能推荐使用[gitment](https://imsun.net/posts/gitment-introduction/) 注册 OAuth Application点击此处 来注册一个新的 OAuth Application 得到一个 client ID 和一个 client secret，将被用于之后的用户登录。 gitment配置配置项如下 123456789101112131415# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: true # Hide &apos;Powered by ...&apos; on footer, and more language: zh-CN # Force language, or auto switch by theme github_user: xxx # MUST HAVE, Your Github Username github_repo: xxx # MUST HAVE, The name of the repo you use to store Gitment comments client_id: xxx # MUST HAVE, Github client id for the Gitment client_secret: xxx # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled github授权后的用户就可以评论了 Valinegitment不太好用，换用Valine Valine是基于LeanCloud的评论系统，支持图片、emoji等 在LeanCloud上新建一个应用，取得其appId和appKey，修改主题配置文件： 1234valine: enable: true appid: xxxx appkey: xxxxx]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Vue双向绑定]]></title>
    <url>%2F2018%2F10%2F08%2F%E5%AE%9E%E7%8E%B0Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[Object.defineProperty()这个API是实现双向绑定的核心，最主要的作用是重写数据的get、set方法。 使用方法： 123456789101112131415161718192021222324252627282930let obj = &#123; singer: "周杰伦"&#125;;let default_value = "青花瓷";Object.defineProperty(obj, "music", &#123; // value: '七里香', // 设置属性的值，下面设置了get set函数，所以这里不能设置 configurable: false, // 是否可以删除属性，默认不能删除 // writable: true, // 是否可以修改对象，下面设置了get set函数，所以这里不能设置 enumerable: true, // music是否可以被枚举，默认是不能被枚举(遍历) //get,set设置时不能设置writable和value，要一对一对设置，交叉设置/同时存在就会报错 get() &#123; // 获取obj.music的时候就会调用get方法 // let default_value = "强行设置get的返回值"; // 打开注释 读取属性永远都是‘强行设置get的返回值’ return default_value; &#125;, set(val) &#123; // 将修改的值重新赋给song default_value = val; &#125;&#125;);console.log(obj.music); // 青花瓷delete obj.music; // configurable设为false 删除无效console.log(obj.music); // 青花瓷obj.music = "听妈妈的话"; console.log(obj.music); // 听妈妈的话for (let key in obj) &#123; // 默认情况下通过defineProperty定义的属性是不能被枚举(遍历)的 // 需要设置enumerable为true才可以 否则只能拿到singer 属性 console.log(key); // singer, music&#125; 实现思路 实现数据监听器Observer，用Object.defineProperty()重写数据的get、set，值更新就在set中通知订阅者更新数据。 实现模板编译Compile，深度遍历dom树，对每个元素节点的指令模板进行替换数据以及订阅数据。 实现Watch用于连接Observer和Compile，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。 流程图代码实现html结构1234567&lt;div id="wrap"&gt; &lt;p v-html="test"&gt;&lt;/p&gt; &lt;input type="text" v-model="form"&gt; &lt;input type="text" v-model="form"&gt; &lt;button @click="changeValue"&gt;改变值&lt;/button&gt; &#123;&#123;form&#125;&#125;&lt;/div&gt; JS调用12345678910111213141516new Vue(&#123; el: '#wrap', data: &#123; form: '这是form的值', test: '&lt;strong&gt;我是粗体&lt;/strong&gt;', obj: &#123; test: 123 &#125; &#125;, methods: &#123; changeValue() &#123; console.log(this.form); this.form = '改变了'; &#125; &#125; &#125;); Vue结构1234567891011class Vue&#123; constructor()&#123;&#125; proxyData()&#123;&#125; observer()&#123;&#125; compile()&#123;&#125; compileText()&#123;&#125;&#125;class Watcher&#123; constructor()&#123;&#125; update()&#123;&#125;&#125; Vue constructor 构造函数主要是数据的初始化 proxyData 数据代理 observer 劫持监听所有数据 compile 解析dom compileText 解析dom里处理纯双花括号的操作 Watcher 更新视图操作 Vue constructor 初始化1234567891011121314class Vue&#123;constructor(options = &#123;&#125;) &#123; this.$el = document.querySelector(options.el); let data = this.data = options.data; // 代理data，使其能直接this.xxx的方式访问data，正常的话需要this.data.xxx Object.keys(data).forEach(key =&gt; &#123; this.proxyData(key); &#125;); this.methods = options.methods; // 事件方法 this.watcherTask = &#123;&#125;; // 需要监听的任务列表 this.observer(data); // 初始化劫持监听所有数据 this.compile(this.$el); // 解析dom &#125;&#125; proxyData 代理data123456789101112131415161718class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key) &#123; let _this = this; Object.defineProperty(_this, key, &#123; configurable: false, enumerable: true, get() &#123; return _this.data[key]; &#125;, set(newVal) &#123; _this.data[key] = newVal; &#125; &#125;); &#125;&#125; 上面主要是代理data到最上层，this.xxx的方式直接访问data observer 劫持监听123456789101112131415161718192021222324252627282930class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key)&#123; ...... &#125; observer(data) &#123; let _this = this; Object.keys(data).forEach(key =&gt; &#123; let value = data[key]; _this.watcherTask[key] = []; Object.defineProperty(data, key, &#123; configurable: false, enumerable: true, get() &#123; return value; &#125;, set(newValue) &#123; if (newValue !== value) &#123; value = newValue; _this.watcherTask[key].forEach(task =&gt; &#123; task.update(); &#125;); &#125; &#125; &#125;) &#125;) &#125;&#125; 同样是使用Object.defineProperty来监听数据，初始化需要订阅的数据。 把需要订阅的数据到push到watcherTask里，等到时候需要更新的时候就可以批量更新数据了。 compile 解析dom123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key)&#123; ...... &#125; observer(data)&#123; ...... &#125; compile(el) &#123; let _this=this; let nodes = el.childNodes; for (let i = 0, len = nodes.length; i &lt; len; i++) &#123; const node = nodes[i]; if (node.nodeType === 3) &#123; let text = node.textContent.trim(); if (!text) &#123; continue; &#125; this.compileText(node, 'textContent'); &#125; else if (node.type === 1) &#123; if (node.childNodes.length &gt; 0) &#123; this.compile(node); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA')) &#123; node.addEventListener('input', (() =&gt; &#123; let attrVal = node.getAttribute('v-model'); this.watcherTask[attrVal].push(new Watcher(node, _this, attrVal, 'value')); // node.removeAttribute('v-model'); return () =&gt; &#123; this.data[attrVal] = node.value; &#125; &#125;)()); &#125; if (node.hasAttribute('v-html')) &#123; let attrVal = node.getAttribute('v-html'); this.watcherTask[attrVal].push(new Watcher(node, _this, attrVal, 'innerHTML')); // node.removeAttribute('v-html'); &#125; this.compileText(node, 'innerHTMl'); if (node.hasAttribute('@click')) &#123; let attrVal = node.getAttribute('@click'); // node.removeAttribute('@click'); node.addEventListener('click', e =&gt; &#123; this.methods[attrVal] &amp;&amp; this.methods[attrVal].bind(_this)() &#125;) &#125; &#125; &#125; &#125; compileText(node, type) &#123; let reg = /\&#123;\&#123;(.*?)\&#125;\&#125;/g; let txt = node.textContent; if (reg.test(txt)) &#123; node.textContent = txt.replace(reg, (matched, value) =&gt; &#123; let tpl = this.watcherTask[value] || []; tpl.push(new Watcher(node, this, value, type)); if (value.split('.').length&gt;1) &#123; let v=null; value.split('.').forEach((val,i)=&gt;&#123; v=!v?this[val]:v[val]; &#125;); return v; &#125;else &#123; return this[value]; &#125; &#125;) &#125; &#125;&#125; 首先我们先遍历el元素下面的所有子节点，node.nodeType === 3 的意思是当前元素是文本节点，node.nodeType === 1 的意思是当前元素是元素节点。因为可能有的是纯文本的形式，如纯双花括号就是纯文本的文本节点，然后通过判断元素节点是否还存在子节点，如果有的话就递归调用compile方法。 Watcher12345678910111213class Watcher &#123; constructor(el, vm, value, type) &#123; this.el = el; this.vm = vm; this.value = value; this.type = type; this.update(); &#125; update() &#123; this.el[this.type] = this.vm.data[this.value]; &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6编程风格]]></title>
    <url>%2F2018%2F09%2F30%2FES6%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[http://es6.ruanyifeng.com/#docs/style]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一台电脑绑定两个git账号]]></title>
    <url>%2F2018%2F09%2F29%2F%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E7%BB%91%E5%AE%9A%E4%B8%A4%E4%B8%AAgit%E8%B4%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[前言公司最近在推公共组件，要求每人分享自己组件到公司的git服务上。由于之前在公司电脑上绑定了自己的git，因此需要在一台电脑上绑定两个git账号。 生成部署新SHH key输入命令1ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 注意不要直接回车，第一步输入存储路径，可以找个其他路径先存放，再重命名后复制到.ssh目录下。 假设原有的自己的私钥和公钥分别命名为id_rsa和id_rsa.pub，新的公司的私钥和公钥分别命名为id_rsa_company和id_rsa_company.pub。 同样把新的公钥id_rsa_company.pub的内容复制到git服务的设置里。 添加秘钥到SSH Agent因为默认只读取id_rsa,为了让SSH识别新的私钥，需将其添加的SSH agent中。123ssh-agent bashssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_company 创建并配置config文件在.ssh目录下创建一个config文本文件,添加相关配置。1234567891011# default Host github.com HostName github.com User xiamijun IdentityFile ~/.ssh/id_rsa# two Host http://git.flyui.cn HostName http://git.flyui.cn User junxie4 IdentityFile ~/.ssh/id_rsa_company 测试ssh链接12ssh -T git@ieit.github.comssh -T git@github.com 如果成功，会显示欢迎信息，并显示用户名。 用户名/邮箱配置为了使提交代码不混淆，需要区分一下用户名和邮箱。 可以清楚全局设置，在每个仓库下单独设置用户名和邮箱，但这样较为繁琐。 由于平常自己的账号使用较多，公司的使用不多，所以使用自己的账号作为全局，公司的账号按需配置。 全局设置：12git config --global user.name &quot;xiamijun&quot;git config --global user.email &quot;171571466@qq.com&quot; 单个仓库设置：12git config user.name &quot;xxx&quot;git config user.email &quot;xxx@company.com&quot; 大功告成~]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eslint进行代码检查]]></title>
    <url>%2F2018%2F09%2F28%2Feslint%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[前言最近项目进行到收尾阶段，公司对于代码质量抓的比较严，后端一般使用sonar进行代码扫描。而JavaScript是弱类型语言，其实很有扫描检查的必要。sonar支持JS和typeScript的扫描，不支持Vue。因此改用eslint进行代码扫描。平常在开发中，都是嫌麻烦把eslint关掉的。。 安装依赖除了安装eslint以外，还需安装eslint-plugin-vue插件来检查Vue代码。直接-g吧。npm install eslint eslint-plugin-vue -g 配置一般推荐使用配置文件进行配置，在项目根目录下创建.eslintrc.json，其中写入各个配置项。如下：12345678910111213141516171819202122232425262728293031323334353637&#123; "root": true, //此项是用来告诉eslint找当前配置文件不能往父级查找 "extends": ["plugin:vue/essential","eslint:recommended"], //vue插件和推荐eslint规则 "parserOptions": &#123; "ecmaVersion": 6, "sourceType": "module", "ecmaFeatures": &#123; "jsx": true &#125; &#125;, //指定为浏览器环境 "env": &#123; "es6": true, "browser": true, "node": true &#125;, "rules": &#123; "camelcase": "error", "eqeqeq": "error", "no-console": "error", "no-alert": "error", "require-jsdoc": ["error", &#123; "require": &#123; "FunctionDeclaration": false, "MethodDefinition": false, "ClassDeclaration": false, "ArrowFunctionExpression": false &#125; &#125;], "new-cap": "error", "brace-style": "error", "comma-dangle": "error", "no-param-reassign": "error" &#125;&#125; 注意json中不能有注释，复制下来记得删除注释。 #规则举几个常用的规则：1234567891011&#123; &quot;no-alert&quot;: 2,//禁止使用alert confirm prompt &quot;no-console&quot;: 2,//禁止使用console &quot;no-const-assign&quot;: 2,//禁止修改const声明的变量 &quot;no-debugger&quot;: 2,//禁止使用debugger &quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &quot;no-dupe-args&quot;: 2,//函数参数不能重复 &quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复 &quot;no-empty&quot;: 2,//块语句中的内容不能为空 &quot;no-eval&quot;: 1,//禁止使用eval&#125; 具体规则见官网 https://eslint.org/docs/rules/ 代码扫描项目根目录运行eslint --ext .js,.vue src。或者将运行结果输出到文件eslint --ext .js,.vue src &gt; log.txt。 分析通过对输出的文件分析，我们项目的错误（警告）有以下几种 报错 规则 规则 Unexpected trailing comma comma-dangle 对象结尾跟随了一个多余的逗号 Expected ‘===’ and instead saw ‘==’ eqeqeq 必须使用全等 ‘util’ is not defined no-undef 不能有声明后未被使用的变量或参数 ‘delSpace’ is defined but never used no-unused-vars 不能有声明后未被使用的变量或参数 Elements in iteration expect to have ‘v-bind:key’ directives vue/require-v-for-key v-for中需v-bind:key Unexpected console statement no-console no-console]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从进程谈JS运行机制]]></title>
    <url>%2F2018%2F09%2F27%2F%E4%BB%8E%E8%BF%9B%E7%A8%8B%E8%B0%88JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程和线程 进程之间相互独立。 一个进程由一个或多个线程组成。 多个线程在进程中协作完成任务。 同一进程下的各个线程之间共享程序的内存空间。 进程是cpu资源分配的最小单位。 线程是cpu调度的最小单位。 浏览器是多进程的 浏览器每打开一个tab标签页，任务管理器会多加一条记录。 浏览器包含哪些进程 Browser进程主进程，只有一个作用：用户交互，如前进，后退。页面的管理，创建和销毁其他进程。网络资源管理，下载。 第三方插件进程 GPU进程用于3D绘制 浏览器渲染进程（浏览器内核）Renderer进程，内部是多线程的 浏览器内核（渲染进程） 页面的渲染，JS的执行，事件的循环，都在这个进程内进行。 渲染进程是多线程的 浏览器渲染进程包含的线程 GUI渲染线程&ensp; &ensp; 解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。&ensp; &ensp; 注：GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程&ensp; &ensp; 例如V8引擎。 事件触发线程&ensp; &ensp; 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）。&ensp; &ensp; 当JS引擎执行如setTimeOut、AJAX异步请求等时，会将对应任务添加到事件线程中。&ensp; &ensp; 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。&ensp; &ensp; 由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。 定时触发器线程&ensp; &ensp; setInternal与 setTimeout所在线程。&ensp; &ensp; 浏览器定时计数器并不是由JavaScript引擎计数的。&ensp; &ensp; 通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）。&ensp; &ensp; 规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程&ensp; &ensp; XMLHttpRequest在连接后通过新开一个线程请求。&ensp; &ensp; 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 Browser进程和浏览器内核（Renderer进程）的通信过程 Browser进程收到用户请求，获取页面内容（如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程。 Renderer进程收到消息，简单解释后，交给渲染线程，然后开始渲染。&ensp; &ensp; 渲染线程接收请求，加载网页并渲染网页。&ensp; &ensp; 可能会有JS线程操作DOM（这样可能会造成回流并重绘）。&ensp; &ensp; 最后Render进程将结果传递给Browser进程。 Browser进程接收到结果并将结果绘制出来。 GUI渲染线程与JS引擎线程互斥 当JS引擎执行时GUI线程会被挂起 巨量计算阻塞页面加载 WebWorker 应对cpu密集型计算 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM） JS引擎线程与worker线程间通过特定的方式通信 JS引擎是单线程的，本质仍然未改变 浏览器渲染流程 解析html建立dom树 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树） 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 从Event Loop谈JS的运行机制概念： JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到执行栈中，开始执行。 定时器定时器是JS引擎检测的么？当然不是了。它是由定时器线程控制（因为JS引擎自己都忙不过来，根本无暇分身）。123setTimeout(function()&#123; console.log('hello!');&#125;,1000); 1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行。 123setTimeout(function()&#123; console.log('hello!');&#125;,0); 以最快的时间内将回调函数推入事件队列中，等待主线程执行。 W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 setTimeout而不是setInterval setInterval是每次都精确的隔一段时间推入一个事件 但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了。 致命问题：累计效应 macrotask与microtask12345678910111213console.log('script start');setTimeout(function()&#123; console.log('setTimeout');&#125;,0);Promise.resolve().then(function()&#123; console.log('promise1');&#125;).then(function()&#123; console.log('promise2');&#125;);console.log('script end'); 正确结果：12345script startscript endpromise1promise2setTimeout 因为Promise里有了一个一个新的概念： microtask JS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task定义和区别 macrotask（又称之为宏任务）&ensp; &ensp; 可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。&ensp; &ensp; 每一个macrotask会从头到尾将这个任务执行完毕，不会执行其它。&ensp; &ensp; 浏览器为了能够使得JS内部macrotask与DOM任务能够有序的执行，会在一个macrotask执行结束后，在下一个macrotask执行开始前，对页面进行重新渲染。（task-&gt;渲染-&gt;task-&gt;...） microtask（又称为微任务）&ensp; &ensp; 可以理解是在当前macrotask执行结束后立即执行的任务。&ensp; &ensp; 也就是说，在当前macrotask任务后，下一个macrotask之前，在渲染之前。&ensp; &ensp; 所以它的响应速度相比setTimeout（setTimeout是macrotask）会更快。 场景 macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask） microtask：Promise，process.nextTick等 总结]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JOSN.stringfy小技巧]]></title>
    <url>%2F2018%2F09%2F27%2FJOSN.stringfy%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[JSON.stringify()的另外两个参数JSON.stringify(value[, replacer [, space]])参数： value：将要被序列化的变量的值 replacer：替代器。如果该参数是一个函数，则被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的JSON字符串中 space：指定缩进用的空白字符串，用于美化输出，可以是数字或者字符串。如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格； 使用函数过滤并序列化对象：123456789101112131415161718// 使用“函数”当替代器function replacer(key, value) &#123; if (typeof value === "string") &#123; return undefined; &#125; return value;&#125;let foo = &#123; foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7&#125;;let jsonString = JSON.stringify(foo, replacer);// &#123;"week":45,"month":7&#125; 使用数组过滤并序列化对象：12345678910111213141516// 使用“数组”当替代器let user = &#123; name: 'zollero', nick: 'z', skills: ['JavaScript', 'CSS', 'HTML5']&#125;;JSON.stringify(user, ['name', 'skills'], 2);// "&#123;// "name": "zollero",// "skills": [// "JavaScript",// "CSS",// "HTML5"// ]// &#125;" 对象的toJSON属性如果一个对象有toJSON属性，当它被序列化的时候，不会对该对象进行序列化，而是将它的toJSON方法的返回值进行序列化。 例子：12345678let obj = &#123; foo: 'foo', toJSON: function () &#123; return 'bar'; &#125;&#125;;JSON.stringify(obj); // '"bar"'JSON.stringify(&#123;x: obj&#125;); // '&#123;"x":"bar"&#125;']]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[background-attachment实现滚动视差]]></title>
    <url>%2F2018%2F09%2F27%2Fbackground-attachment%E5%AE%9E%E7%8E%B0%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[background-attachment实现滚动视差background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动。 值 描述 scroll 默认值。背景图像会随着页面其余部分的滚动而移动。 fixed 当页面的其余部分滚动时，背景图像不会移动。 效果]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS函数收藏]]></title>
    <url>%2F2018%2F09%2F27%2FJS%E5%87%BD%E6%95%B0%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[Array.prototype.findIndex()返回数组中满足回调函数函数的第一个元素的索引。否则返回-1。 语法arr.findIndex(callback)举例：返回对象数组中value出现的索引123let index=arr.findIndex((item)=&gt;&#123; return item.value===value;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS函数参数值校验]]></title>
    <url>%2F2018%2F09%2F27%2FJS%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%80%BC%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[在ES6中，为函数增加了参数默认值的特性，可以为参数设定一些默认值，可以让代码更简洁，可维护。 其实，我们可以通过这个特性来做函数参数值的校验。 首先，函数的参数可以是任意类型的值，也可以是函数，比如下面这个：123456789101112131415function fix(a = getA()) &#123; console.log('a', a)&#125;function getA() &#123; console.log('get a') return 2&#125;fix(1);// a 1fix();// get a// a 2 可以看出，如果在调用fix 时传了参数a，则不会执行函数getA，只有当不传递参数a时，才会执行函数getA。 这时候，我们可以利用这一特性，为参数a添加一个必传的校验，代码如下：12345678910111213function fix(a = require()) &#123; console.log('a', a)&#125;function require() &#123; throw new Error('缺少了参数 a')&#125;fix(1);// a 1fix();// Uncaught Error: 缺少了参数 a]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构赋值和拓展运算符]]></title>
    <url>%2F2018%2F09%2F27%2F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%92%8C%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[用解构赋值过滤对象属性1234567891011// 过滤掉对象 types 中的 inner 和 outer 属性const &#123; inner, outer, ...restProps &#125; = &#123; inner: 'This is inner', outer: 'This is outer', v1: '1', v2: '2', v4: '3'&#125;;console.log(restProps);// &#123;v1: "1", v2: "2", v4: "3"&#125; 用解构赋值获取嵌套对象的属性从一堆嵌套很深的对象属性中，很方便地拿到我们想要的那一个。1234567891011121314151617// 通过解构赋值获取嵌套对象的值const car = &#123; model: 'bmw 2018', engine: &#123; v6: true, turbo: true, vin: 12345 &#125;&#125;;// 这里使用 ES6 中的简单写法，使用 &#123; vin &#125; 替代 &#123; vin: vin &#125;const modalAndVIN = (&#123; model, engine: &#123; vin &#125;&#125;) =&gt; &#123; console.log(`model: $&#123;model&#125;, vin: $&#123;vin&#125;`);&#125;modalAndVIN(car);// "model: bmw 2018, vin: 12345" 拓展运算符合并对象拓展运算符，可以用来解构数组，也可以用来解构对象，它可以将对象中的所有属性展开。 通过这个特性，我们可以做一些对象合并的操作。12345678910111213// 使用拓展运算符合并对象，在后面的属性会重写前面相同属性的值const obj1 = &#123; a: 1, b: 2, c: 3 &#125;;const obj2 = &#123; c: 5, d: 9 &#125;;const merged = &#123; ...obj1, ...obj2 &#125;;console.log(merged);// &#123;a: 1, b: 2, c: 5, d: 9&#125;const obj3 = &#123; a: 1, b: 2 &#125;;const obj4 = &#123; c: 3, d: &#123; e: 4, ...obj3 &#125; &#125;;console.log(obj4);// &#123;c: 3, d: &#123;a: 1, b: 2, e: 4&#125; &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo排坑实录]]></title>
    <url>%2F2018%2F09%2F21%2Fhexo%E6%8E%92%E5%9D%91%E5%AE%9E%E5%BD%95%2F</url>
    <content type="text"><![CDATA[hexo是什么hexo是基于Node.js的博客框架，支持 Markdown，可部署到 GitHub Pages。由于是基于Node.js的，因此对前端程序员天然友好。官网：https://hexo.io/zh-cn/安装部署教程网上较多，在此不再赘述，仅记录安装部署过程中遇到的坑及解决办法。 部署完毕后，githubPage打开显示404，项目setting中的githubPage项提示：The tag fancybox on line 77 in theme/landspace/README.md is not recognized Liquid tag解决办法：123rm -rf .deploy_githexo ghexo d 提示没有git仓库解决办法：运行git init 其他问题windows下尽量不使用cmd其他无法解决的问题建议去github issue看一看]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
